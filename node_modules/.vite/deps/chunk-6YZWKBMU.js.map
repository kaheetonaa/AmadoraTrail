{
  "version": 3,
  "sources": ["../../ol/render/EventType.js", "../../ol/layer/Property.js", "../../ol/layer/Base.js", "../../ol/layer/Layer.js", "../../ol/layer/Group.js", "../../ol/expr/expression.js", "../../ol/expr/cpu.js", "../../ol/render/canvas/style.js", "../../ol/layer/BaseVector.js", "../../ol/render/Event.js"],
  "sourcesContent": ["/**\n * @module ol/render/EventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered before a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#prerender\n   * @api\n   */\n  PRERENDER: 'prerender',\n\n  /**\n   * Triggered after a layer is rendered.\n   * @event module:ol/render/Event~RenderEvent#postrender\n   * @api\n   */\n  POSTRENDER: 'postrender',\n\n  /**\n   * Triggered before layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#precompose\n   * @api\n   */\n  PRECOMPOSE: 'precompose',\n\n  /**\n   * Triggered after layers are composed.  When dispatched by the map, the event object will not have\n   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only\n   * WebGL layers currently dispatch this event.\n   * @event module:ol/render/Event~RenderEvent#postcompose\n   * @api\n   */\n  POSTCOMPOSE: 'postcompose',\n\n  /**\n   * Triggered when rendering is complete, i.e. all sources and tiles have\n   * finished loading for the current viewport, and all tiles are faded in.\n   * The event object will not have a `context` set.\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\n   * @api\n   */\n  RENDERCOMPLETE: 'rendercomplete',\n};\n\n/**\n * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes\n */\n\n/**\n * @typedef {'postrender'|'prerender'} LayerRenderEventTypes\n */\n", "/**\n * @module ol/layer/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  OPACITY: 'opacity',\n  VISIBLE: 'visible',\n  EXTENT: 'extent',\n  Z_INDEX: 'zIndex',\n  MAX_RESOLUTION: 'maxResolution',\n  MIN_RESOLUTION: 'minResolution',\n  MAX_ZOOM: 'maxZoom',\n  MIN_ZOOM: 'minZoom',\n  SOURCE: 'source',\n  MAP: 'map',\n};\n", "/**\n * @module ol/layer/Base\n */\nimport BaseObject from '../Object.js';\nimport LayerProperty from './Property.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {clamp} from '../math.js';\n\n/**\n * A css color, or a function called with a view resolution returning a css color.\n *\n * @typedef {string|function(number):string} BackgroundColor\n * @api\n */\n\n/**\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\n * is observable, and has get/set accessors.\n *\n * @api\n */\nclass BaseLayer extends BaseObject {\n  /**\n   * @param {Options} options Layer options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {BackgroundColor|false}\n     * @private\n     */\n    this.background_ = options.background;\n\n    /**\n     * @type {Object<string, *>}\n     */\n    const properties = Object.assign({}, options);\n    if (typeof options.properties === 'object') {\n      delete properties.properties;\n      Object.assign(properties, options.properties);\n    }\n\n    properties[LayerProperty.OPACITY] =\n      options.opacity !== undefined ? options.opacity : 1;\n    assert(\n      typeof properties[LayerProperty.OPACITY] === 'number',\n      'Layer opacity must be a number',\n    );\n\n    properties[LayerProperty.VISIBLE] =\n      options.visible !== undefined ? options.visible : true;\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\n    properties[LayerProperty.MAX_RESOLUTION] =\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[LayerProperty.MIN_RESOLUTION] =\n      options.minResolution !== undefined ? options.minResolution : 0;\n    properties[LayerProperty.MIN_ZOOM] =\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\n    properties[LayerProperty.MAX_ZOOM] =\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.className_ =\n      properties.className !== undefined ? properties.className : 'ol-layer';\n    delete properties.className;\n\n    this.setProperties(properties);\n\n    /**\n     * @type {import(\"./Layer.js\").State}\n     * @private\n     */\n    this.state_ = null;\n  }\n\n  /**\n   * Get the background for this layer.\n   * @return {BackgroundColor|false} Layer background.\n   */\n  getBackground() {\n    return this.background_;\n  }\n\n  /**\n   * @return {string} CSS class name.\n   */\n  getClassName() {\n    return this.className_;\n  }\n\n  /**\n   * This method is not meant to be called by layers or layer renderers because the state\n   * is incorrect if the layer is included in a layer group.\n   *\n   * @param {boolean} [managed] Layer is managed.\n   * @return {import(\"./Layer.js\").State} Layer state.\n   */\n  getLayerState(managed) {\n    /** @type {import(\"./Layer.js\").State} */\n    const state =\n      this.state_ ||\n      /** @type {?} */ ({\n        layer: this,\n        managed: managed === undefined ? true : managed,\n      });\n    const zIndex = this.getZIndex();\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    state.minZoom = this.getMinZoom();\n    state.maxZoom = this.getMaxZoom();\n    this.state_ = state;\n\n    return state;\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be\n   *     modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    return abstract();\n  }\n\n  /**\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n  getExtent() {\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\n      this.get(LayerProperty.EXTENT)\n    );\n  }\n\n  /**\n   * Return the maximum resolution of the layer. Returns Infinity if\n   * the layer has no maximum resolution set.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMaxResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum resolution of the layer. Returns 0 if\n   * the layer has no minimum resolution set.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMinResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum zoom level of the layer. Returns -Infinity if\n   * the layer has no minimum zoom set.\n   * @return {number} The minimum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\n  }\n\n  /**\n   * Return the maximum zoom level of the layer. Returns Infinity if\n   * the layer has no maximum zoom set.\n   * @return {number} The maximum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\n  }\n\n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n  getOpacity() {\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    return abstract();\n  }\n\n  /**\n   * Return the value of this layer's `visible` property. To find out whether the layer\n   * is visible on a map, use `isVisible()` instead.\n   * @return {boolean} The value of the `visible` property of the layer.\n   * @observable\n   * @api\n   */\n  getVisible() {\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\n  }\n\n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. Returns undefined if the layer is unmanaged.\n   * @return {number|undefined} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n  getZIndex() {\n    return /** @type {number|undefined} */ (this.get(LayerProperty.Z_INDEX));\n  }\n\n  /**\n   * Sets the background color.\n   * @param {BackgroundColor} [background] Background color.\n   */\n  setBackground(background) {\n    this.background_ = background;\n    this.changed();\n  }\n\n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n  setExtent(extent) {\n    this.set(LayerProperty.EXTENT, extent);\n  }\n\n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMaxResolution(maxResolution) {\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n  }\n\n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMinResolution(minResolution) {\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n  }\n\n  /**\n   * Set the maximum zoom (exclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} maxZoom The maximum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMaxZoom(maxZoom) {\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\n  }\n\n  /**\n   * Set the minimum zoom (inclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} minZoom The minimum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMinZoom(minZoom) {\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\n  }\n\n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n  setOpacity(opacity) {\n    assert(typeof opacity === 'number', 'Layer opacity must be a number');\n    this.set(LayerProperty.OPACITY, opacity);\n  }\n\n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n  setVisible(visible) {\n    this.set(LayerProperty.VISIBLE, visible);\n  }\n\n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n  setZIndex(zindex) {\n    this.set(LayerProperty.Z_INDEX, zindex);\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.state_) {\n      this.state_.layer = null;\n      this.state_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default BaseLayer;\n", "/**\n * @module ol/layer/Layer\n */\nimport BaseLayer from './Base.js';\nimport EventType from '../events/EventType.js';\nimport LayerProperty from './Property.js';\nimport RenderEventType from '../render/EventType.js';\nimport View from '../View.js';\nimport {assert} from '../asserts.js';\nimport {intersects} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../Map.js\").FrameState):HTMLElement} RenderFunction\n */\n\n/**\n * @typedef {'sourceready'|'change:source'} LayerEventType\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     LayerEventType, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|LayerEventType|\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\n * construction.\n * @property {import(\"../Map.js\").default|null} [map] Map.\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\n * HTML element. Will overwrite the default rendering for the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./Layer.js\").default} layer Layer.\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\n * @property {boolean} visible Visible.\n * @property {boolean} managed Managed.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {number} zIndex ZIndex.\n * @property {number} maxResolution Maximum resolution.\n * @property {number} minResolution Minimum resolution.\n * @property {number} minZoom Minimum zoom.\n * @property {number} maxZoom Maximum zoom.\n */\n\n/**\n * @classdesc\n * Base class from which all layer types are derived. This should only be instantiated\n * in the case where a custom layer is added to the map with a custom `render` function.\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\n *\n * A visual representation of raster or vector map data.\n * Layers group together those properties that pertain to how the data is to be\n * displayed, irrespective of the source of that data.\n *\n * Layers are usually added to a map with [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\n * internally. These unmanaged layers are associated with the map using\n * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.\n *\n * A generic `change` event is fired when the state of the source changes.\n * A `sourceready` event is fired when the layer's source is ready.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @fires import(\"../events/Event.js\").BaseEvent#sourceready\n *\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\n * @api\n */\nclass Layer extends BaseLayer {\n  /**\n   * @param {Options<SourceType>} options Layer options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.source;\n\n    super(baseOptions);\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {LayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapPrecomposeKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapRenderKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceChangeKey_ = null;\n\n    /**\n     * @private\n     * @type {RendererType}\n     */\n    this.renderer_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.sourceReady_ = false;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.rendered = false;\n\n    // Overwrite default render method with a custom one\n    if (options.render) {\n      this.render = options.render;\n    }\n\n    if (options.map) {\n      this.setMap(options.map);\n    }\n\n    this.addChangeListener(\n      LayerProperty.SOURCE,\n      this.handleSourcePropertyChange_,\n    );\n\n    const source = options.source\n      ? /** @type {SourceType} */ (options.source)\n      : null;\n    this.setSource(source);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   * @override\n   */\n  getLayersArray(array) {\n    array = array ? array : [];\n    array.push(this);\n    return array;\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   * @override\n   */\n  getLayerStatesArray(states) {\n    states = states ? states : [];\n    states.push(this.getLayerState());\n    return states;\n  }\n\n  /**\n   * Get the layer source.\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n  getSource() {\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\n  }\n\n  /**\n   * @return {SourceType|null} The source being rendered.\n   */\n  getRenderSource() {\n    return this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   * @override\n   */\n  getSourceState() {\n    const source = this.getSource();\n    return !source ? 'undefined' : source.getState();\n  }\n\n  /**\n   * @private\n   */\n  handleSourceChange_() {\n    this.changed();\n    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {\n      return;\n    }\n    this.sourceReady_ = true;\n    this.dispatchEvent('sourceready');\n  }\n\n  /**\n   * @private\n   */\n  handleSourcePropertyChange_() {\n    if (this.sourceChangeKey_) {\n      unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    this.sourceReady_ = false;\n    const source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = listen(\n        source,\n        EventType.CHANGE,\n        this.handleSourceChange_,\n        this,\n      );\n      if (source.getState() === 'ready') {\n        this.sourceReady_ = true;\n        setTimeout(() => {\n          this.dispatchEvent('sourceready');\n        }, 0);\n      }\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.renderer_) {\n      return Promise.resolve([]);\n    }\n    return this.renderer_.getFeatures(pixel);\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    if (!this.renderer_ || !this.rendered) {\n      return null;\n    }\n    return this.renderer_.getData(pixel);\n  }\n\n  /**\n   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and\n   * extent, not set to `visible: false`, and not inside a layer group that is set\n   * to `visible: false`.\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\n   * Only required when the layer is not added to a map.\n   * @return {boolean} The layer is visible in the map view.\n   * @api\n   */\n  isVisible(view) {\n    let frameState;\n    const map = this.getMapInternal();\n    if (!view && map) {\n      view = map.getView();\n    }\n    if (view instanceof View) {\n      frameState = {\n        viewState: view.getState(),\n        extent: view.calculateExtent(),\n      };\n    } else {\n      frameState = view;\n    }\n    if (!frameState.layerStatesArray && map) {\n      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();\n    }\n    let layerState;\n    if (frameState.layerStatesArray) {\n      layerState = frameState.layerStatesArray.find(\n        (layerState) => layerState.layer === this,\n      );\n      if (!layerState) {\n        return false;\n      }\n    } else {\n      layerState = this.getLayerState();\n    }\n\n    const layerExtent = this.getExtent();\n\n    return (\n      inView(layerState, frameState.viewState) &&\n      (!layerExtent || intersects(layerExtent, frameState.extent))\n    );\n  }\n\n  /**\n   * Get the attributions of the source of this layer for the given view.\n   * @param {View|import(\"../View.js\").ViewStateLayerStateExtent} [view] View or {@link import(\"../Map.js\").FrameState}.\n   * Only required when the layer is not added to a map.\n   * @return {Array<string>} Attributions for this layer at the given view.\n   * @api\n   */\n  getAttributions(view) {\n    if (!this.isVisible(view)) {\n      return [];\n    }\n    const getAttributions = this.getSource()?.getAttributions();\n    if (!getAttributions) {\n      return [];\n    }\n    const frameState =\n      view instanceof View ? view.getViewStateAndExtent() : view;\n    let attributions = getAttributions(frameState);\n    if (!Array.isArray(attributions)) {\n      attributions = [attributions];\n    }\n    return attributions;\n  }\n\n  /**\n   * In charge to manage the rendering of the layer. One layer type is\n   * bounded with one layer renderer.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  render(frameState, target) {\n    const layerRenderer = this.getRenderer();\n\n    if (layerRenderer.prepareFrame(frameState)) {\n      this.rendered = true;\n      return layerRenderer.renderFrame(frameState, target);\n    }\n    return null;\n  }\n\n  /**\n   * Called when a layer is not visible during a map render.\n   */\n  unrender() {\n    this.rendered = false;\n  }\n\n  /** @return {string} Declutter */\n  getDeclutter() {\n    return undefined;\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {}\n\n  /**\n   * When the renderer follows a layout -> render approach, do the final rendering here.\n   * @param {import('../Map.js').FrameState} frameState Frame state\n   */\n  renderDeferred(frameState) {\n    const layerRenderer = this.getRenderer();\n    if (!layerRenderer) {\n      return;\n    }\n    layerRenderer.renderDeferred(frameState);\n  }\n\n  /**\n   * For use inside the library only.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMapInternal(map) {\n    if (!map) {\n      this.unrender();\n    }\n    this.set(LayerProperty.MAP, map);\n  }\n\n  /**\n   * For use inside the library only.\n   * @return {import(\"../Map.js\").default|null} Map.\n   */\n  getMapInternal() {\n    return this.get(LayerProperty.MAP);\n  }\n\n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link module:ol/Map~Map#addLayer} instead.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    if (this.mapPrecomposeKey_) {\n      unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = listen(\n        map,\n        RenderEventType.PRECOMPOSE,\n        this.handlePrecompose_,\n        this,\n      );\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} renderEvent Render event\n   * @private\n   */\n  handlePrecompose_(renderEvent) {\n    const layerStatesArray =\n      /** @type {import(\"../render/Event.js\").default} */ (renderEvent)\n        .frameState.layerStatesArray;\n    const layerState = this.getLayerState(false);\n    assert(\n      !layerStatesArray.some(\n        (arrayLayerState) => arrayLayerState.layer === layerState.layer,\n      ),\n      'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.',\n    );\n    layerStatesArray.push(layerState);\n  }\n\n  /**\n   * Set the layer source.\n   * @param {SourceType|null} source The layer source.\n   * @observable\n   * @api\n   */\n  setSource(source) {\n    this.set(LayerProperty.SOURCE, source);\n  }\n\n  /**\n   * Get the renderer for this layer.\n   * @return {RendererType|null} The layer renderer.\n   */\n  getRenderer() {\n    if (!this.renderer_) {\n      this.renderer_ = this.createRenderer();\n    }\n    return this.renderer_;\n  }\n\n  /**\n   * @return {boolean} The layer has a renderer.\n   */\n  hasRenderer() {\n    return !!this.renderer_;\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {RendererType} A layer renderer.\n   * @protected\n   */\n  createRenderer() {\n    return null;\n  }\n\n  /**\n   * This will clear the renderer so that a new one can be created next time it is needed\n   */\n  clearRenderer() {\n    if (this.renderer_) {\n      this.renderer_.dispose();\n      delete this.renderer_;\n    }\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.clearRenderer();\n    this.setSource(null);\n    super.disposeInternal();\n  }\n}\n\n/**\n * Return `true` if the layer is visible and if the provided view state\n * has resolution and zoom levels that are in range of the layer's min/max.\n * @param {State} layerState Layer state.\n * @param {import(\"../View.js\").State} viewState View state.\n * @return {boolean} The layer is visible at the given view state.\n */\nexport function inView(layerState, viewState) {\n  if (!layerState.visible) {\n    return false;\n  }\n  const resolution = viewState.resolution;\n  if (\n    resolution < layerState.minResolution ||\n    resolution >= layerState.maxResolution\n  ) {\n    return false;\n  }\n  const zoom = viewState.zoom;\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\n}\n\nexport default Layer;\n", "/**\n * @module ol/layer/Group\n */\nimport BaseLayer from './Base.js';\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport {assert} from '../asserts.js';\nimport {clear} from '../obj.js';\nimport {getIntersection} from '../extent.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {'addlayer'|'removelayer'} GroupEventType\n */\n\n/**\n * @classdesc\n * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from\n * the group or one of its child groups.  When a layer group is added to or removed from another layer group,\n * a single event will be triggered (instead of one per layer in the group added or removed).\n */\nexport class GroupEvent extends Event {\n  /**\n   * @param {GroupEventType} type The event type.\n   * @param {BaseLayer} layer The layer.\n   */\n  constructor(type, layer) {\n    super(type);\n\n    /**\n     * The added or removed layer.\n     * @type {BaseLayer}\n     * @api\n     */\n    this.layer = layer;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     'change:layers', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<import(\"./Base.js\").default>|Collection<import(\"./Base.js\").default>} [layers] Child layers.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  LAYERS: 'layers',\n};\n\n/**\n * @classdesc\n * A {@link module:ol/Collection~Collection} of layers that are handled together.\n *\n * A generic `change` event is triggered when the group/Collection changes.\n *\n * @api\n */\nclass LayerGroup extends BaseLayer {\n  /**\n   * @param {Options} [options] Layer options.\n   */\n  constructor(options) {\n    options = options || {};\n    const baseOptions = /** @type {Options} */ (Object.assign({}, options));\n    delete baseOptions.layers;\n\n    let layers = options.layers;\n\n    super(baseOptions);\n\n    /***\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {GroupOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.layersListenerKeys_ = [];\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.listenerKeys_ = {};\n\n    this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);\n\n    if (layers) {\n      if (Array.isArray(layers)) {\n        layers = new Collection(layers.slice(), {unique: true});\n      } else {\n        assert(\n          typeof (/** @type {?} */ (layers).getArray) === 'function',\n          'Expected `layers` to be an array or a `Collection`',\n        );\n      }\n    } else {\n      layers = new Collection(undefined, {unique: true});\n    }\n\n    this.setLayers(layers);\n  }\n\n  /**\n   * @private\n   */\n  handleLayerChange_() {\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  handleLayersChanged_() {\n    this.layersListenerKeys_.forEach(unlistenByKey);\n    this.layersListenerKeys_.length = 0;\n\n    const layers = this.getLayers();\n    this.layersListenerKeys_.push(\n      listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this),\n      listen(\n        layers,\n        CollectionEventType.REMOVE,\n        this.handleLayersRemove_,\n        this,\n      ),\n    );\n\n    for (const id in this.listenerKeys_) {\n      this.listenerKeys_[id].forEach(unlistenByKey);\n    }\n    clear(this.listenerKeys_);\n\n    const layersArray = layers.getArray();\n    for (let i = 0, ii = layersArray.length; i < ii; i++) {\n      const layer = layersArray[i];\n      this.registerLayerListeners_(layer);\n      this.dispatchEvent(new GroupEvent('addlayer', layer));\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {BaseLayer} layer The layer.\n   */\n  registerLayerListeners_(layer) {\n    const listenerKeys = [\n      listen(\n        layer,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleLayerChange_,\n        this,\n      ),\n      listen(layer, EventType.CHANGE, this.handleLayerChange_, this),\n    ];\n\n    if (layer instanceof LayerGroup) {\n      listenerKeys.push(\n        listen(layer, 'addlayer', this.handleLayerGroupAdd_, this),\n        listen(layer, 'removelayer', this.handleLayerGroupRemove_, this),\n      );\n    }\n\n    this.listenerKeys_[getUid(layer)] = listenerKeys;\n  }\n\n  /**\n   * @param {GroupEvent} event The layer group event.\n   */\n  handleLayerGroupAdd_(event) {\n    this.dispatchEvent(new GroupEvent('addlayer', event.layer));\n  }\n\n  /**\n   * @param {GroupEvent} event The layer group event.\n   */\n  handleLayerGroupRemove_(event) {\n    this.dispatchEvent(new GroupEvent('removelayer', event.layer));\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\n   * @private\n   */\n  handleLayersAdd_(collectionEvent) {\n    const layer = collectionEvent.element;\n    this.registerLayerListeners_(layer);\n    this.dispatchEvent(new GroupEvent('addlayer', layer));\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\n   * @private\n   */\n  handleLayersRemove_(collectionEvent) {\n    const layer = collectionEvent.element;\n    const key = getUid(layer);\n    this.listenerKeys_[key].forEach(unlistenByKey);\n    delete this.listenerKeys_[key];\n    this.dispatchEvent(new GroupEvent('removelayer', layer));\n    this.changed();\n  }\n\n  /**\n   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @return {!Collection<import(\"./Base.js\").default>} Collection of\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  getLayers() {\n    return /** @type {!Collection<import(\"./Base.js\").default>} */ (\n      this.get(Property.LAYERS)\n    );\n  }\n\n  /**\n   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @param {!Collection<import(\"./Base.js\").default>} layers Collection of\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  setLayers(layers) {\n    const collection = this.getLayers();\n    if (collection) {\n      const currentLayers = collection.getArray();\n      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {\n        this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));\n      }\n    }\n\n    this.set(Property.LAYERS, layers);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   * @override\n   */\n  getLayersArray(array) {\n    array = array !== undefined ? array : [];\n    this.getLayers().forEach(function (layer) {\n      layer.getLayersArray(array);\n    });\n    return array;\n  }\n\n  /**\n   * Get the layer states list and use this groups z-index as the default\n   * for all layers in this and nested groups, if it is unset at this point.\n   * If dest is not provided and this group's z-index is undefined\n   * 0 is used a the default z-index.\n   * @param {Array<import(\"./Layer.js\").State>} [dest] Optional list\n   * of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   * @override\n   */\n  getLayerStatesArray(dest) {\n    const states = dest !== undefined ? dest : [];\n    const pos = states.length;\n\n    this.getLayers().forEach(function (layer) {\n      layer.getLayerStatesArray(states);\n    });\n\n    const ownLayerState = this.getLayerState();\n    let defaultZIndex = ownLayerState.zIndex;\n    if (!dest && ownLayerState.zIndex === undefined) {\n      defaultZIndex = 0;\n    }\n    for (let i = pos, ii = states.length; i < ii; i++) {\n      const layerState = states[i];\n      layerState.opacity *= ownLayerState.opacity;\n      layerState.visible = layerState.visible && ownLayerState.visible;\n      layerState.maxResolution = Math.min(\n        layerState.maxResolution,\n        ownLayerState.maxResolution,\n      );\n      layerState.minResolution = Math.max(\n        layerState.minResolution,\n        ownLayerState.minResolution,\n      );\n      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);\n      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);\n      if (ownLayerState.extent !== undefined) {\n        if (layerState.extent !== undefined) {\n          layerState.extent = getIntersection(\n            layerState.extent,\n            ownLayerState.extent,\n          );\n        } else {\n          layerState.extent = ownLayerState.extent;\n        }\n      }\n      if (layerState.zIndex === undefined) {\n        layerState.zIndex = defaultZIndex;\n      }\n    }\n\n    return states;\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   * @override\n   */\n  getSourceState() {\n    return 'ready';\n  }\n}\n\nexport default LayerGroup;\n", "/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {fromString as colorFromString} from '../color.js';\nimport {toSize} from '../size.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\n *   * `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.\n *   * `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a\n *     feature property. The result is `undefined` when there is nothing at the specified key or index.\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\n *   * `['resolution']` returns the current resolution\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` The current zoom level (WebGL only).\n *   * `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line\n *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.\n *      Please note that the M component will be linearly interpolated between the two points composing a segment.\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\n *     (Canvas only).\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\n *     (Canvas only).\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\n *     (Canvas only).\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,\n *     `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4 (WebGL only).\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const SizeType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n  [SizeType]: 'size',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * @param {number} type The type.\n * @return {boolean} The type is one of the specific types (not any or a union type).\n */\nfunction isSpecific(type) {\n  return type in typeNames;\n}\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    if (!isSpecific(type)) {\n      throw new Error(\n        `literal expressions must have a specific type, got ${typeName(type)}`,\n      );\n    }\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {boolean} geometryType The style uses the feature geometry type.\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    geometryType: false,\n  };\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {number} expectedType The expected type.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, expectedType, context) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      if (isType(expectedType, StringType)) {\n        return new LiteralExpression(StringType, encoded ? 'true' : 'false');\n      }\n      if (!includesType(expectedType, BooleanType)) {\n        throw new Error(\n          `got a boolean, but expected ${typeName(expectedType)}`,\n        );\n      }\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      if (isType(expectedType, SizeType)) {\n        return new LiteralExpression(SizeType, toSize(encoded));\n      }\n      if (isType(expectedType, BooleanType)) {\n        return new LiteralExpression(BooleanType, !!encoded);\n      }\n      if (isType(expectedType, StringType)) {\n        return new LiteralExpression(StringType, encoded.toString());\n      }\n      if (!includesType(expectedType, NumberType)) {\n        throw new Error(`got a number, but expected ${typeName(expectedType)}`);\n      }\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      if (isType(expectedType, ColorType)) {\n        return new LiteralExpression(ColorType, colorFromString(encoded));\n      }\n      if (isType(expectedType, BooleanType)) {\n        return new LiteralExpression(BooleanType, !!encoded);\n      }\n      if (!includesType(expectedType, StringType)) {\n        throw new Error(`got a string, but expected ${typeName(expectedType)}`);\n      }\n      return new LiteralExpression(StringType, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, expectedType, context);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('expected an array of numbers');\n    }\n  }\n\n  if (isType(expectedType, SizeType)) {\n    if (encoded.length !== 2) {\n      throw new Error(\n        `expected an array of two values for a size, got ${encoded.length}`,\n      );\n    }\n    return new LiteralExpression(SizeType, encoded);\n  }\n\n  if (isType(expectedType, ColorType)) {\n    if (encoded.length === 3) {\n      return new LiteralExpression(ColorType, [...encoded, 1]);\n    }\n    if (encoded.length === 4) {\n      return new LiteralExpression(ColorType, encoded);\n    }\n    throw new Error(\n      `expected an array of 3 or 4 values for a color, got ${encoded.length}`,\n    );\n  }\n\n  if (!includesType(expectedType, NumberArrayType)) {\n    throw new Error(\n      `got an array of numbers, but expected ${typeName(expectedType)}`,\n    );\n  }\n\n  return new LiteralExpression(NumberArrayType, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  LineMetric: 'line-metric',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Coalesce: 'coalesce',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n  ToString: 'to-string',\n  Has: 'has',\n};\n\n/**\n * @typedef {function(Array, number, ParsingContext):Expression} Parser\n *\n * Second argument is the expected type.\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),\n  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),\n  [Ops.Concat]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(StringType),\n  ),\n  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),\n  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),\n  [Ops.Resolution]: createCallExpressionParser(withNoArgs),\n  [Ops.Zoom]: createCallExpressionParser(withNoArgs),\n  [Ops.Time]: createCallExpressionParser(withNoArgs),\n  [Ops.Any]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.All]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.Not]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.Equal]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.NotEqual]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.GreaterThan]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.LessThan]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.LessThanOrEqualTo]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Multiply]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfReturnType,\n  ),\n  [Ops.Coalesce]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfReturnType,\n  ),\n  [Ops.Divide]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Add]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Subtract]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Clamp]: createCallExpressionParser(\n    hasArgsCount(3, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Mod]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Pow]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Abs]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Floor]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Ceil]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Round]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Sin]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Cos]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Atan]: createCallExpressionParser(\n    hasArgsCount(1, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Sqrt]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Match]: createCallExpressionParser(\n    hasArgsCount(4, Infinity),\n    hasEvenArgs,\n    withMatchArgs,\n  ),\n  [Ops.Between]: createCallExpressionParser(\n    hasArgsCount(3, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Interpolate]: createCallExpressionParser(\n    hasArgsCount(6, Infinity),\n    hasEvenArgs,\n    withInterpolateArgs,\n  ),\n  [Ops.Case]: createCallExpressionParser(\n    hasArgsCount(3, Infinity),\n    hasOddArgs,\n    withCaseArgs,\n  ),\n  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),\n  [Ops.Number]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.String]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.Array]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Color]: createCallExpressionParser(\n    hasArgsCount(1, 4),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Band]: createCallExpressionParser(\n    hasArgsCount(1, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Palette]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withPaletteArgs,\n  ),\n  [Ops.ToString]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(BooleanType | NumberType | StringType | ColorType),\n  ),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator\n *\n * An argument validator applies various checks to an encoded expression arguments and\n * returns the parsed arguments if any.  The second argument is the return type of the call expression.\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n  const args = new Array(argsCount);\n  for (let i = 0; i < argsCount; ++i) {\n    const key = encoded[i + 1];\n    switch (typeof key) {\n      case 'number': {\n        args[i] = new LiteralExpression(NumberType, key);\n        break;\n      }\n      case 'string': {\n        args[i] = new LiteralExpression(StringType, key);\n        break;\n      }\n      default: {\n        throw new Error(\n          `expected a string key or numeric array index for a get operation, got ${key}`,\n        );\n      }\n    }\n    if (i === 0) {\n      context.properties.add(String(key));\n    }\n  }\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, returnType, context) {\n  const name = encoded[1];\n  if (typeof name !== 'string') {\n    throw new Error('expected a string argument for var operation');\n  }\n  context.variables.add(name);\n\n  return [new LiteralExpression(StringType, name)];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, returnType, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesGeometryType(encoded, returnType, context) {\n  context.geometryType = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction hasArgsCount(minArgs, maxArgs) {\n  return function (encoded, returnType, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `expected ${range} arguments for ${operation}, got ${argCount}`,\n      );\n    }\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withArgsOfReturnType(encoded, returnType, context) {\n  const argCount = encoded.length - 1;\n  /**\n   * @type {Array<Expression>}\n   */\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    const expression = parse(encoded[i + 1], returnType, context);\n    args[i] = expression;\n  }\n  return args;\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsOfType(argType) {\n  return function (encoded, returnType, context) {\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], argType, context);\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasOddArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `expected an odd number of arguments for ${operation}, got ${argCount} instead`,\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasEvenArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`,\n    );\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction withMatchArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n\n  const inputType = StringType | NumberType | BooleanType;\n\n  const input = parse(encoded[1], inputType, context);\n\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    try {\n      const match = parse(encoded[i + 2], input.type, context);\n      args[i] = match;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 1} of match expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 3], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 2} of match expression: ${err.message}`,\n      );\n    }\n  }\n\n  return [input, ...args, fallback];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withInterpolateArgs(encoded, returnType, context) {\n  const interpolationType = encoded[1];\n  /**\n   * @type {number}\n   */\n  let base;\n  switch (interpolationType[0]) {\n    case 'linear':\n      base = 1;\n      break;\n    case 'exponential':\n      const b = interpolationType[1];\n      if (typeof b !== 'number' || b <= 0) {\n        throw new Error(\n          `expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(b)} instead`,\n        );\n      }\n      base = b;\n      break;\n    default:\n      throw new Error(\n        `invalid interpolation type: ${JSON.stringify(interpolationType)}`,\n      );\n  }\n\n  const interpolation = new LiteralExpression(NumberType, base);\n\n  let input;\n  try {\n    input = parse(encoded[2], NumberType, context);\n  } catch (err) {\n    throw new Error(\n      `failed to parse argument 1 in interpolate expression: ${err.message}`,\n    );\n  }\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    try {\n      const stop = parse(encoded[i + 3], NumberType, context);\n      args[i] = stop;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 4], returnType, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`,\n      );\n    }\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withCaseArgs(encoded, returnType, context) {\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    try {\n      const condition = parse(encoded[i + 1], BooleanType, context);\n      args[i] = condition;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i} of case expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 2], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 1} of case expression: ${err.message}`,\n      );\n    }\n  }\n\n  args[args.length - 1] = fallback;\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withInArgs(encoded, returnType, context) {\n  let haystack = encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `the second argument for the \"in\" operator must be an array`,\n    );\n  }\n  /**\n   * @type {number}\n   */\n  let needleType;\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `for the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions`,\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `failed to parse \"in\" expression: the literal operator must be followed by an array`,\n      );\n    }\n    haystack = haystack[1];\n    needleType = StringType;\n  } else {\n    needleType = NumberType;\n  }\n\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    try {\n      const arg = parse(haystack[i], needleType, context);\n      args[i] = arg;\n    } catch (err) {\n      throw new Error(\n        `failed to parse haystack item ${i} for \"in\" expression: ${err.message}`,\n      );\n    }\n  }\n\n  const needle = parse(encoded[1], needleType, context);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withPaletteArgs(encoded, returnType, context) {\n  let index;\n  try {\n    index = parse(encoded[1], NumberType, context);\n  } catch (err) {\n    throw new Error(\n      `failed to parse first argument in palette expression: ${err.message}`,\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('the second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    let color;\n    try {\n      color = parse(colors[i], ColorType, context);\n    } catch (err) {\n      throw new Error(\n        `failed to parse color at index ${i} in palette expression: ${err.message}`,\n      );\n    }\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `the palette color at index ${i} must be a literal value`,\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected\n * to return the parsed arguments.\n * @return {Parser} The parser.\n */\nfunction createCallExpressionParser(...validators) {\n  return function (encoded, returnType, context) {\n    const operator = encoded[0];\n\n    /**\n     * @type {Array<Expression>}\n     */\n    let args;\n    for (let i = 0; i < validators.length; i++) {\n      const parsed = validators[i](encoded, returnType, context);\n      if (i == validators.length - 1) {\n        if (!parsed) {\n          throw new Error(\n            'expected last argument validator to return the parsed args',\n          );\n        }\n        args = parsed;\n      }\n    }\n    return new CallExpression(returnType, operator, ...args);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {number} returnType The expected return type of the call expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, returnType, context) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`unknown operator: ${operator}`);\n  }\n  return parser(encoded, returnType, context);\n}\n\n/**\n * Returns a simplified geometry type suited for the `geometry-type` operator\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\n */\nexport function computeGeometryType(geometry) {\n  if (!geometry) {\n    return '';\n  }\n  const type = geometry.getType();\n  switch (type) {\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n      return type;\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));\n    case 'Circle':\n      return 'Polygon';\n    case 'GeometryCollection':\n      return computeGeometryType(\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries()[0],\n      );\n    default:\n      return '';\n  }\n}\n", "/**\n * @module ol/expr/cpu\n */\n\nimport {ColorType, LiteralExpression, Ops, parse} from './expression.js';\nimport {\n  fromString,\n  lchaToRgba,\n  normalize,\n  rgbaToLcha,\n  toString,\n  withAlpha,\n} from '../color.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n * @property {string|number|null} featureId The feature id.\n * @property {string} geometryType Geometry type of the current object.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n    featureId: null,\n    geometryType: '',\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, type, context);\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    // convert colors to array if possible\n    if (expression.type === ColorType && typeof expression.value === 'string') {\n      const colorValue = fromString(expression.value);\n      return function () {\n        return colorValue;\n      };\n    }\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n    case Ops.Coalesce: {\n      return compileAssertionExpression(expression, context);\n    }\n    case Ops.Get:\n    case Ops.Var:\n    case Ops.Has: {\n      return compileAccessorExpression(expression, context);\n    }\n    case Ops.Id: {\n      return (context) => context.featureId;\n    }\n    case Ops.GeometryType: {\n      return (context) => context.geometryType;\n    }\n    case Ops.Concat: {\n      const args = expression.args.map((e) => compileExpression(e, context));\n      return (context) =>\n        ''.concat(...args.map((arg) => arg(context).toString()));\n    }\n    case Ops.Resolution: {\n      return (context) => context.resolution;\n    }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Between:\n    case Ops.In:\n    case Ops.Not: {\n      return compileLogicalExpression(expression, context);\n    }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo: {\n      return compileComparisonExpression(expression, context);\n    }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt: {\n      return compileNumericExpression(expression, context);\n    }\n    case Ops.Case: {\n      return compileCaseExpression(expression, context);\n    }\n    case Ops.Match: {\n      return compileMatchExpression(expression, context);\n    }\n    case Ops.Interpolate: {\n      return compileInterpolateExpression(expression, context);\n    }\n    case Ops.ToString: {\n      return compileConvertExpression(expression, context);\n    }\n    default: {\n      throw new Error(`Unsupported operator ${operator}`);\n    }\n    // TODO: unimplemented\n    // Ops.Zoom\n    // Ops.Time\n    // Ops.Array\n    // Ops.Color\n    // Ops.Band\n    // Ops.Palette\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Coalesce: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          const value = args[i](context);\n          if (typeof value !== 'undefined' && value !== null) {\n            return value;\n          }\n        }\n        throw new Error('Expected one of the values to be non-null');\n      };\n    }\n    case Ops.Number:\n    case Ops.String: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          const value = args[i](context);\n          if (typeof value === type) {\n            return value;\n          }\n        }\n        throw new Error(`Expected one of the values to be a ${type}`);\n      };\n    }\n    default: {\n      throw new Error(`Unsupported assertion operator ${type}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = /** @type {LiteralExpression} */ (expression.args[0]);\n  const name = /** @type {string} */ (nameExpression.value);\n  switch (expression.operator) {\n    case Ops.Get: {\n      return (context) => {\n        const args = expression.args;\n        let value = context.properties[name];\n        for (let i = 1, ii = args.length; i < ii; ++i) {\n          const keyExpression = /** @type {LiteralExpression} */ (args[i]);\n          const key = /** @type {string|number} */ (keyExpression.value);\n          value = value[key];\n        }\n        return value;\n      };\n    }\n    case Ops.Var: {\n      return (context) => context.variables[name];\n    }\n    case Ops.Has: {\n      return (context) => {\n        const args = expression.args;\n        if (!(name in context.properties)) {\n          return false;\n        }\n        let value = context.properties[name];\n        for (let i = 1, ii = args.length; i < ii; ++i) {\n          const keyExpression = /** @type {LiteralExpression} */ (args[i]);\n          const key = /** @type {string|number} */ (keyExpression.value);\n          if (!value || !Object.hasOwn(value, key)) {\n            return false;\n          }\n          value = value[key];\n        }\n        return true;\n      };\n    }\n    default: {\n      throw new Error(`Unsupported accessor operator ${expression.operator}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal: {\n      return (context) => left(context) === right(context);\n    }\n    case Ops.NotEqual: {\n      return (context) => left(context) !== right(context);\n    }\n    case Ops.LessThan: {\n      return (context) => left(context) < right(context);\n    }\n    case Ops.LessThanOrEqualTo: {\n      return (context) => left(context) <= right(context);\n    }\n    case Ops.GreaterThan: {\n      return (context) => left(context) > right(context);\n    }\n    case Ops.GreaterThanOrEqualTo: {\n      return (context) => left(context) >= right(context);\n    }\n    default: {\n      throw new Error(`Unsupported comparison operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (args[i](context)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    case Ops.All: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (!args[i](context)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n    case Ops.Between: {\n      return (context) => {\n        const value = args[0](context);\n        const min = args[1](context);\n        const max = args[2](context);\n        return value >= min && value <= max;\n      };\n    }\n    case Ops.In: {\n      return (context) => {\n        const value = args[0](context);\n        for (let i = 1; i < length; ++i) {\n          if (value === args[i](context)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    case Ops.Not: {\n      return (context) => !args[0](context);\n    }\n    default: {\n      throw new Error(`Unsupported logical operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply: {\n      return (context) => {\n        let value = 1;\n        for (let i = 0; i < length; ++i) {\n          value *= args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Divide: {\n      return (context) => args[0](context) / args[1](context);\n    }\n    case Ops.Add: {\n      return (context) => {\n        let value = 0;\n        for (let i = 0; i < length; ++i) {\n          value += args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Subtract: {\n      return (context) => args[0](context) - args[1](context);\n    }\n    case Ops.Clamp: {\n      return (context) => {\n        const value = args[0](context);\n        const min = args[1](context);\n        if (value < min) {\n          return min;\n        }\n        const max = args[2](context);\n        if (value > max) {\n          return max;\n        }\n        return value;\n      };\n    }\n    case Ops.Mod: {\n      return (context) => args[0](context) % args[1](context);\n    }\n    case Ops.Pow: {\n      return (context) => Math.pow(args[0](context), args[1](context));\n    }\n    case Ops.Abs: {\n      return (context) => Math.abs(args[0](context));\n    }\n    case Ops.Floor: {\n      return (context) => Math.floor(args[0](context));\n    }\n    case Ops.Ceil: {\n      return (context) => Math.ceil(args[0](context));\n    }\n    case Ops.Round: {\n      return (context) => Math.round(args[0](context));\n    }\n    case Ops.Sin: {\n      return (context) => Math.sin(args[0](context));\n    }\n    case Ops.Cos: {\n      return (context) => Math.cos(args[0](context));\n    }\n    case Ops.Atan: {\n      if (length === 2) {\n        return (context) => Math.atan2(args[0](context), args[1](context));\n      }\n      return (context) => Math.atan(args[0](context));\n    }\n    case Ops.Sqrt: {\n      return (context) => Math.sqrt(args[0](context));\n    }\n    default: {\n      throw new Error(`Unsupported numeric operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileCaseExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    for (let i = 0; i < length - 1; i += 2) {\n      const condition = args[i](context);\n      if (condition) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileInterpolateExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    const base = args[0](context);\n    const value = args[1](context);\n\n    let previousInput;\n    let previousOutput;\n    for (let i = 2; i < length; i += 2) {\n      const input = args[i](context);\n      let output = args[i + 1](context);\n      const isColor = Array.isArray(output);\n      if (isColor) {\n        output = withAlpha(output);\n      }\n      if (input >= value) {\n        if (i === 2) {\n          return output;\n        }\n        if (isColor) {\n          return interpolateColor(\n            base,\n            value,\n            previousInput,\n            previousOutput,\n            input,\n            output,\n          );\n        }\n        return interpolateNumber(\n          base,\n          value,\n          previousInput,\n          previousOutput,\n          input,\n          output,\n        );\n      }\n      previousInput = input;\n      previousOutput = output;\n    }\n    return previousOutput;\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileConvertExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.ToString: {\n      return (context) => {\n        const value = args[0](context);\n        if (expression.args[0].type === ColorType) {\n          return toString(value);\n        }\n        return value.toString();\n      };\n    }\n    default: {\n      throw new Error(`Unsupported convert operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {number} output1 The first output value.\n * @param {number} input2 The second input value.\n * @param {number} output2 The second output value.\n * @return {number} The interpolated value.\n */\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return output1;\n  }\n  const along = value - input1;\n  const factor =\n    base === 1\n      ? along / delta\n      : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\n  return output1 + factor * (output2 - output1);\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {import('../color.js').Color} rgba1 The first output value.\n * @param {number} input2 The second input value.\n * @param {import('../color.js').Color} rgba2 The second output value.\n * @return {import('../color.js').Color} The interpolated color.\n */\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return rgba1;\n  }\n  const lcha1 = rgbaToLcha(rgba1);\n  const lcha2 = rgbaToLcha(rgba2);\n  let deltaHue = lcha2[2] - lcha1[2];\n  if (deltaHue > 180) {\n    deltaHue -= 360;\n  } else if (deltaHue < -180) {\n    deltaHue += 360;\n  }\n\n  const lcha = [\n    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),\n    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),\n    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),\n    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3]),\n  ];\n  return normalize(lchaToRgba(lcha));\n}\n", "/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  StringType,\n  computeGeometryType,\n  newParsingContext,\n} from '../../expr/expression.js';\nimport {NO_COLOR} from '../../color.js';\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\nimport {isEmpty} from '../../obj.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    if (parsingContext.geometryType) {\n      evaluationContext.geometryType = computeGeometryType(\n        feature.getGeometry(),\n      );\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    let nonNullCount = 0;\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter =\n      'filter' in rule\n        ? buildExpression(rule.filter, BooleanType, context)\n        : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n\n    compiledRules[i] = {filter, styles};\n  }\n\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n\n  if (\n    !evaluateFill &&\n    !evaluateStroke &&\n    !evaluateText &&\n    !evaluateImage &&\n    !isEmpty(flatStyle)\n  ) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error(\n      'No fill, stroke, point, or text symbolizer properties in style: ' +\n        JSON.stringify(flatStyle),\n    );\n  }\n\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  let evaluateColor;\n  if (prefix + 'fill-pattern-src' in flatStyle) {\n    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);\n  } else {\n    if (flatStyle[prefix + 'fill-color'] === 'none') {\n      // avoids hit detection\n      return (context) => null;\n    }\n\n    evaluateColor = colorLikeEvaluator(\n      flatStyle,\n      prefix + 'fill-color',\n      context,\n    );\n  }\n  if (!evaluateColor) {\n    return null;\n  }\n\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === NO_COLOR) {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-width',\n    context,\n  );\n\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'stroke-color',\n    context,\n  );\n\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n\n  const evaluateLineCap = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-cap',\n    context,\n  );\n\n  const evaluateLineJoin = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-join',\n    context,\n  );\n\n  const evaluateLineDash = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash',\n    context,\n  );\n\n  const evaluateLineDashOffset = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash-offset',\n    context,\n  );\n\n  const evaluateMiterLimit = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-miter-limit',\n    context,\n  );\n\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === NO_COLOR) {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (\n        lineJoin !== 'bevel' &&\n        lineJoin !== 'round' &&\n        lineJoin !== 'miter'\n      ) {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n\n  const evaluateBackgroundFill = buildFill(\n    flatStyle,\n    prefix + 'background-',\n    context,\n  );\n\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n\n  const evaluateBackgroundStroke = buildStroke(\n    flatStyle,\n    prefix + 'background-',\n    context,\n  );\n\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n\n  const evaluateMaxAngle = numberEvaluator(\n    flatStyle,\n    prefix + 'max-angle',\n    context,\n  );\n\n  const evaluateOffsetX = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-x',\n    context,\n  );\n\n  const evaluateOffsetY = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-y',\n    context,\n  );\n\n  const evaluateOverflow = booleanEvaluator(\n    flatStyle,\n    prefix + 'overflow',\n    context,\n  );\n\n  const evaluatePlacement = stringEvaluator(\n    flatStyle,\n    prefix + 'placement',\n    context,\n  );\n\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n\n  const evaluateJustify = stringEvaluator(\n    flatStyle,\n    prefix + 'justify',\n    context,\n  );\n\n  const evaluateBaseline = stringEvaluator(\n    flatStyle,\n    prefix + 'baseline',\n    context,\n  );\n\n  const evaluateKeepUpright = booleanEvaluator(\n    flatStyle,\n    prefix + 'keep-upright',\n    context,\n  );\n\n  const evaluatePadding = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'padding',\n    context,\n  );\n\n  // The following properties are not currently settable\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const text = new Text({declutterMode});\n\n  return function (context) {\n    text.setText(evaluateValue(context));\n\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (\n        textAlign !== 'left' &&\n        textAlign !== 'center' &&\n        textAlign !== 'right' &&\n        textAlign !== 'end' &&\n        textAlign !== 'start'\n      ) {\n        throw new Error(\n          'Expected left, right, center, start, or end for text-align',\n        );\n      }\n      text.setTextAlign(textAlign);\n    }\n\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (\n        textBaseline !== 'bottom' &&\n        textBaseline !== 'top' &&\n        textBaseline !== 'middle' &&\n        textBaseline !== 'alphabetic' &&\n        textBaseline !== 'hanging'\n      ) {\n        throw new Error(\n          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline',\n        );\n      }\n      text.setTextBaseline(textBaseline);\n    }\n\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n\n    if (evaluateKeepUpright) {\n      text.setKeepUpright(evaluateKeepUpright(context));\n    }\n\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(\n    flatStyle,\n    prefix + 'anchor',\n    context,\n  );\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateOpacity = numberEvaluator(\n    flatStyle,\n    prefix + 'opacity',\n    context,\n  );\n\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context,\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-x-units',\n  );\n  const anchorYUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-y-units',\n  );\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const radiusName = prefix + 'radius';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n  const radius = requireNumber(flatStyle[radiusName], radiusName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context,\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  // the remaining properties are not currently settable\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius2,\n    angle,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context,\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context,\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context,\n  );\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode',\n  );\n\n  const circle = new Circle({\n    radius: 5, // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\nfunction patternEvaluator(flatStyle, prefix, context) {\n  const srcEvaluator = stringEvaluator(\n    flatStyle,\n    prefix + 'pattern-src',\n    context,\n  );\n  const offsetEvaluator = sizeEvaluator(\n    flatStyle,\n    prefix + 'pattern-offset',\n    context,\n  );\n  const patternSizeEvaluator = sizeEvaluator(\n    flatStyle,\n    prefix + 'pattern-size',\n    context,\n  );\n  const colorEvaluator = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'color',\n    context,\n  );\n  return function (context) {\n    return {\n      src: srcEvaluator(context),\n      offset: offsetEvaluator && offsetEvaluator(context),\n      size: patternSizeEvaluator && patternSizeEvaluator(context),\n      color: colorEvaluator && colorEvaluator(context),\n    };\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], ColorType, context);\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.\n */\nfunction sizeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireSize(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    NumberArrayType | NumberType,\n    context,\n  );\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (\n    encoded.length !== 2 ||\n    typeof encoded[0] !== 'number' ||\n    typeof encoded[1] !== 'number'\n  ) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (\n    encoded !== 'bottom-left' &&\n    encoded !== 'bottom-right' &&\n    encoded !== 'top-left' &&\n    encoded !== 'top-right'\n  ) {\n    throw new Error(\n      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`,\n    );\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} A number or an array of two numbers.\n */\nfunction requireSize(value, property) {\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  return requireSize(value, property);\n}\n", "/**\n * @module ol/layer/BaseVector\n */\nimport Layer from './Layer.js';\nimport RBush from 'rbush';\nimport Style, {\n  createDefaultStyle,\n  toFunction as toStyleFunction,\n} from '../style/Style.js';\nimport {\n  flatStylesToStyleFunction,\n  rulesToStyleFunction,\n} from '../render/canvas/style.js';\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/Vector.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import('../Feature').FeatureLike} FeatureType\n * @template {import(\"../source/Vector.js\").default<FeatureType>|import(\"../source/VectorTile.js\").default<FeatureType>} VectorSourceType<FeatureType>\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {VectorSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\n * layers or groups of layers separately, use different truthy values for `declutter`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will\n * be recreated during animations. This means that no vectors will be shown clipped, but the\n * setting will have a performance impact for large amounts of vector data. When set to `false`,\n * batches will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will\n * be recreated during interactions. See also `updateWhileAnimating`.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  RENDER_ORDER: 'renderOrder',\n};\n\n/**\n * @classdesc\n * Vector data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import('../Feature').FeatureLike} FeatureType\n * @template {import(\"../source/Vector.js\").default<FeatureType>|import(\"../source/VectorTile.js\").default<FeatureType>} VectorSourceType<FeatureType>\n * @extends {Layer<VectorSourceType, RendererType>}\n * @template {import(\"../renderer/canvas/VectorLayer.js\").default|import(\"../renderer/canvas/VectorTileLayer.js\").default|import(\"../renderer/canvas/VectorImageLayer.js\").default|import(\"../renderer/webgl/PointsLayer.js\").default} RendererType\n * @api\n */\nclass BaseVectorLayer extends Layer {\n  /**\n   * @param {Options<FeatureType, VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.style;\n    delete baseOptions.renderBuffer;\n    delete baseOptions.updateWhileAnimating;\n    delete baseOptions.updateWhileInteracting;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.declutter_ = options.declutter ? String(options.declutter) : undefined;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderBuffer_ =\n      options.renderBuffer !== undefined ? options.renderBuffer : 100;\n\n    /**\n     * User provided style.\n     * @type {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike}\n     * @private\n     */\n    this.style_ = null;\n\n    /**\n     * Style function for use within the library.\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     * @private\n     */\n    this.styleFunction_ = undefined;\n\n    this.setStyle(options.style);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileAnimating_ =\n      options.updateWhileAnimating !== undefined\n        ? options.updateWhileAnimating\n        : false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileInteracting_ =\n      options.updateWhileInteracting !== undefined\n        ? options.updateWhileInteracting\n        : false;\n  }\n\n  /**\n   * @return {string} Declutter group.\n   * @override\n   */\n  getDeclutter() {\n    return this.declutter_;\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   * @override\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * @return {number|undefined} Render buffer.\n   */\n  getRenderBuffer() {\n    return this.renderBuffer_;\n  }\n\n  /**\n   * @return {function(import(\"../Feature.js\").default, import(\"../Feature.js\").default): number|null|undefined} Render\n   *     order.\n   */\n  getRenderOrder() {\n    return /** @type {import(\"../render.js\").OrderFunction|null|undefined} */ (\n      this.get(Property.RENDER_ORDER)\n    );\n  }\n\n  /**\n   * Get the style for features.  This returns whatever was passed to the `style`\n   * option at construction or to the `setStyle` method.\n   * @return {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null|undefined} Layer style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Get the style function.\n   * @return {import(\"../style/Style.js\").StyleFunction|undefined} Layer style function.\n   * @api\n   */\n  getStyleFunction() {\n    return this.styleFunction_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     animating.\n   */\n  getUpdateWhileAnimating() {\n    return this.updateWhileAnimating_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     interacting.\n   */\n  getUpdateWhileInteracting() {\n    return this.updateWhileInteracting_;\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../layer/Layer.js\").State} layerState Layer state.\n   * @override\n   */\n  renderDeclutter(frameState, layerState) {\n    const declutterGroup = this.getDeclutter();\n    if (declutterGroup in frameState.declutter === false) {\n      frameState.declutter[declutterGroup] = new RBush(9);\n    }\n    this.getRenderer().renderDeclutter(frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../render.js\").OrderFunction|null|undefined} renderOrder\n   *     Render order.\n   */\n  setRenderOrder(renderOrder) {\n    this.set(Property.RENDER_ORDER, renderOrder);\n  }\n\n  /**\n   * Set the style for features.  This can be a single style object, an array\n   * of styles, or a function that takes a feature and resolution and returns\n   * an array of styles. If set to `null`, the layer has no style (a `null` style),\n   * so only features that have their own styles will be rendered in the layer. Call\n   * `setStyle()` without arguments to reset to the default style. See\n   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.\n   *\n   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object\n   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):\n   * ```js\n   * vectorLayer.setStyle({\n   *   \"fill-color\": \"yellow\",\n   *   \"stroke-color\": \"black\",\n   *   \"stroke-width\": 4\n   * })\n   * ```\n   *\n   * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\n   * @api\n   */\n  setStyle(style) {\n    this.style_ = style === undefined ? createDefaultStyle : style;\n    const styleLike = toStyleLike(style);\n    this.styleFunction_ =\n      style === null ? undefined : toStyleFunction(styleLike);\n    this.changed();\n  }\n\n  /**\n   * @param {boolean|string|number} declutter Declutter images and text.\n   * @api\n   */\n  setDeclutter(declutter) {\n    this.declutter_ = declutter ? String(declutter) : undefined;\n    this.changed();\n  }\n}\n\n/**\n * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat\n * styles, and arrays of rules are converted into style functions.\n *\n * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\n * @return {import(\"../style/Style.js\").StyleLike|null} The style.\n */\nfunction toStyleLike(style) {\n  if (style === undefined) {\n    return createDefaultStyle;\n  }\n  if (!style) {\n    return null;\n  }\n  if (typeof style === 'function') {\n    return style;\n  }\n  if (style instanceof Style) {\n    return style;\n  }\n  if (!Array.isArray(style)) {\n    return flatStylesToStyleFunction([style]);\n  }\n  if (style.length === 0) {\n    return [];\n  }\n\n  const length = style.length;\n  const first = style[0];\n\n  if (first instanceof Style) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      const candidate = style[i];\n      if (!(candidate instanceof Style)) {\n        throw new Error('Expected a list of style instances');\n      }\n      styles[i] = candidate;\n    }\n    return styles;\n  }\n\n  if ('style' in first) {\n    /**\n     * @type Array<import(\"../style/flat.js\").Rule>\n     */\n    const rules = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      const candidate = style[i];\n      if (!('style' in candidate)) {\n        throw new Error('Expected a list of rules with a style property');\n      }\n      rules[i] = candidate;\n    }\n    return rulesToStyleFunction(rules);\n  }\n\n  const flatStyles =\n    /** @type {Array<import(\"../style/flat.js\").FlatStyle>} */ (style);\n  return flatStylesToStyleFunction(flatStyles);\n}\n\nexport default BaseVectorLayer;\n", "/**\n * @module ol/render/Event\n */\n\nimport Event from '../events/Event.js';\n\nclass RenderEvent extends Event {\n  /**\n   * @param {import(\"./EventType.js\").default} type Type.\n   * @param {import(\"../transform.js\").Transform} [inversePixelTransform] Transform for\n   *     CSS pixels to rendered pixels.\n   * @param {import(\"../Map.js\").FrameState} [frameState] Frame state.\n   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.\n   */\n  constructor(type, inversePixelTransform, frameState, context) {\n    super(type);\n\n    /**\n     * Transform from CSS pixels (relative to the top-left corner of the map viewport)\n     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.\n     * @type {import(\"../transform.js\").Transform|undefined}\n     * @api\n     */\n    this.inversePixelTransform = inversePixelTransform;\n\n    /**\n     * An object representing the current render frame state.\n     * @type {import(\"../Map.js\").FrameState|undefined}\n     * @api\n     */\n    this.frameState = frameState;\n\n    /**\n     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,\n     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL\n     * context.\n     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}\n     * @api\n     */\n    this.context = context;\n  }\n}\n\nexport default RenderEvent;\n"],
  "mappings": "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",
  "names": ["EventType_default", "layerState", "EventType_default", "context", "context", "Property", "Event_default"]
}
