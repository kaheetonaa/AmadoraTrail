{
  "version": 3,
  "sources": ["../../ol/source/DataTile.js", "../../ol/source/ImageTile.js"],
  "sourcesContent": ["/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {toPromise} from '../functions.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\n */\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {AbortSignal} signal An abort controller signal.\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\n * underlying tile grid does not have a known extent.\n */\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {string} [key] Key for use in caching tiles.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\n * @extends TileSource<TileType>\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @private\n     */\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {CrossOriginAttribute}\n     */\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\n\n    /**\n     * @type {import(\"../transform.js\").Transform|null}\n     */\n    this.transformMatrix = null;\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!TileType} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const sourceTileGrid =\n      this.tileGrid || this.getTileGridForProjection(sourceProj || targetProj);\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      sourceTileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(sourceTileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1],\n        );\n      }),\n    );\n\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj,\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj: sourceProj || targetProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.gutter_,\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio),\n        transformMatrix: this.transformMatrix,\n      },\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\n    );\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new ReprojDataTile(options))\n    );\n    tile.key = this.getKey();\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {TileType|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      projection &&\n      ((sourceProjection && !equivalent(sourceProjection, projection)) ||\n        this.transformMatrix)\n    ) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n\n    const sourceLoader = this.loader_;\n\n    const controller = new AbortController();\n\n    /**\n     * @type {LoaderOptions}\n     */\n    const loaderOptions = {\n      signal: controller.signal,\n      crossOrigin: this.crossOrigin_,\n    };\n\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\n    if (!tileCoord) {\n      return null;\n    }\n\n    const requestZ = tileCoord[0];\n    const requestX = tileCoord[1];\n    const requestY = tileCoord[2];\n    const range = this.getTileGrid()?.getFullTileRange(requestZ);\n    if (range) {\n      loaderOptions.maxY = range.getHeight() - 1;\n    }\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\n      });\n    }\n\n    /**\n     * @type {import(\"../DataTile.js\").Options}\n     */\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n        controller: controller,\n      },\n      this.tileOptions,\n    );\n\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new DataTile(options))\n    );\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      this.tileGrid &&\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\nexport default DataTileSource;\n", "/**\n * @module ol/source/ImageTile\n */\nimport DataTileSource from './DataTile.js';\nimport {expandUrl, pickUrl, renderXYZTemplate} from '../uri.js';\n\n/**\n * Image tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns an {@link import(\"../DataTile.js\").ImageLike image} or a promise for the same.\n *\n * @typedef {function(number, number, number, import(\"./DataTile.js\").LoaderOptions):(import(\"../DataTile.js\").ImageLike|Promise<import(\"../DataTile.js\").ImageLike>)} Loader\n */\n\n/**\n * @typedef {function(number, number, number, import(\"./DataTile.js\").LoaderOptions):string} UrlGetter\n */\n\n/**\n * @typedef {string | Array<string> | UrlGetter} UrlLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {UrlLike} [url] The image URL template.  In addition to a single URL template, an array of URL templates or a function\n * can be provided.  If a function is provided, it will be called with z, x, y tile coordinates and loader options and should\n * return a URL.\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns an {@link import(\"../DataTile.js\").ImageLike image} for a tile or a promise for the same.\n * The promise should not resolve until the image is loaded.  If the `url` option is provided, a loader will be created.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=true] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.\n * @property {import('./DataTile.js').CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\nconst loadError = new Error('Image failed to load');\n\n/**\n * @param {string} template The image url template.\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @param {import('./DataTile.js').LoaderOptions} options The loader options.\n * @return {Promise<HTMLImageElement>} Resolves with a loaded image.\n */\nfunction loadImage(template, z, x, y, options) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.crossOrigin = options.crossOrigin ?? null;\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => reject(loadError));\n    image.src = renderXYZTemplate(template, z, x, y, options.maxY);\n  });\n}\n\n/**\n * @param {Array<string>} templates The url templates.\n * @return {Loader} The image loader.\n */\nfunction makeLoaderFromTemplates(templates) {\n  return function (z, x, y, options) {\n    const template = pickUrl(templates, z, x, y);\n    return loadImage(template, z, x, y, options);\n  };\n}\n\n/**\n * @param {UrlGetter} getter The url getter.\n * @return {Loader} The image loader.\n */\nfunction makeLoaderFromGetter(getter) {\n  return function (z, x, y, options) {\n    const url = getter(z, x, y, options);\n    return loadImage(url, z, x, y, options);\n  };\n}\n\n/**\n * @param {UrlLike} url The URL-like option.\n * @return {Loader} The tile loader.\n */\nfunction makeLoaderFromUrlLike(url) {\n  /**\n   * @type {Loader}\n   */\n  let loader;\n\n  if (Array.isArray(url)) {\n    loader = makeLoaderFromTemplates(url);\n  } else if (typeof url === 'string') {\n    const urls = expandUrl(url);\n    loader = makeLoaderFromTemplates(urls);\n  } else if (typeof url === 'function') {\n    loader = makeLoaderFromGetter(url);\n  } else {\n    throw new Error(\n      'The url option must be a single template, an array of templates, or a function for getting a URL',\n    );\n  }\n  return loader;\n}\n\nlet keyCount = 0;\n\n/**\n * @param {UrlLike} url The URL-like option.\n * @return {string} A key for the URL.\n */\nfunction keyFromUrlLike(url) {\n  if (Array.isArray(url)) {\n    return url.join('\\n');\n  }\n\n  if (typeof url === 'string') {\n    return url;\n  }\n\n  ++keyCount;\n  return 'url-function-key-' + keyCount;\n}\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @extends DataTileSource<import(\"../ImageTile.js\").default>\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass ImageTileSource extends DataTileSource {\n  /**\n   * @param {Options} [options] DataTile source options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @type {Loader}\n     */\n    let loader = options.loader;\n\n    /**\n     * @type {string}\n     */\n    let key;\n\n    if (options.url) {\n      loader = makeLoaderFromUrlLike(options.url);\n      key = keyFromUrlLike(options.url);\n    }\n\n    /**\n     * @type {import('./Source.js').State}\n     */\n    const state = !loader ? 'loading' : options.state;\n\n    const wrapX = options.wrapX === undefined ? true : options.wrapX;\n\n    super({\n      loader: loader,\n      key: key,\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize,\n      gutter: options.gutter,\n      maxResolution: options.maxResolution,\n      projection: options.projection,\n      tileGrid: options.tileGrid,\n      state: state,\n      wrapX: wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      crossOrigin: options.crossOrigin,\n      zDirection: options.zDirection,\n    });\n  }\n\n  /**\n   * @param {UrlLike} url The new URL.\n   * @api\n   */\n  setUrl(url) {\n    const loader = makeLoaderFromUrlLike(url);\n    this.setLoader(loader);\n    this.setKey(keyFromUrlLike(url));\n    if (this.getState() !== 'ready') {\n      this.setState('ready');\n    }\n  }\n}\n\nexport default ImageTileSource;\n"],
  "mappings": "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",
  "names": ["z", "x", "y", "DataTile_default", "DataTile_default"]
}
