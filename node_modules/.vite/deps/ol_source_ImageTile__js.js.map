{
  "version": 3,
  "sources": ["../../ol/source/TileEventType.js", "../../ol/tilegrid/TileGrid.js", "../../ol/tilegrid.js", "../../ol/source/Tile.js", "../../ol/source/DataTile.js", "../../ol/uri.js", "../../ol/source/ImageTile.js"],
  "sourcesContent": ["/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error. Note that this is not the\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\n   * for details.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n", "/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, {\n  createOrUpdate as createOrUpdateTileRange,\n} from '../TileRange.js';\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport {ceil, clamp, floor} from '../math.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {toSize} from '../size.js';\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 5;\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(\n      isSorted(\n        this.resolutions_,\n        /**\n         * @param {number} a First resolution\n         * @param {number} b Second resolution\n         * @return {number} Comparison result\n         */\n        (a, b) => b - a,\n        true,\n      ),\n      '`resolutions` must be sorted in descending order',\n    );\n\n    // check if we've got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(\n        this.origins_.length == this.resolutions_.length,\n        'Number of `origins` and `resolutions` must be equal',\n      );\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      'Either `origin` or `origins` must be configured, never both',\n    );\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(\n        this.tileSizes_.length == this.resolutions_.length,\n        'Number of `tileSizes` and `resolutions` must be equal',\n      );\n    }\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n          ? DEFAULT_TILE_SIZE\n          : null;\n    assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      'Either `tileSize` or `tileSizes` must be configured, never both',\n    );\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map((size, z) => {\n        const tileRange = new TileRange(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1),\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      });\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    tempTileRange,\n    tempExtent,\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\n    }\n    while (z >= this.minZoom) {\n      if (x !== undefined && y !== undefined) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          tempTileRange,\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    }\n    return this.origins_[z];\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          tempTileRange,\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        tempExtent || this.tmpExtent_,\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        tempTileRange,\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        tempTileRange,\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);\n    const minX = tmpTileCoord[1];\n    const minY = tmpTileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);\n    const maxX = tmpTileCoord[1];\n    const maxY = tmpTileCoord[2];\n    return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, tempExtent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord,\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord,\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord,\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    return this.tileSizes_[z];\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default|null} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    }\n    return this.fullTileRanges_[z];\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n   *     If 0, the nearest resolution will be used.\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n   *\n   * For example to change tile Z at the midpoint of zoom levels\n   * ```js\n   * function(value, high, low) {\n   *   return value - low * Math.sqrt(high / low);\n   * }\n   * ```\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0,\n    );\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * The tile with the provided tile coordinate intersects the given viewport.\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n   */\n  tileCoordIntersectsViewport(tileCoord, viewport) {\n    return intersectsLinearRing(\n      viewport,\n      0,\n      viewport.length,\n      2,\n      this.getTileCoordExtent(tileCoord),\n    );\n  }\n\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\nexport default TileGrid;\n", "/**\n * @module ol/tilegrid\n */\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {toSize} from './size.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth,\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution,\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n", "/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport {abstract, getUid} from '../util.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {withinExtentAndZ} from '../tilecoord.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Deprecated.  Use the cacheSize option on the layer instead.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n *\n * @template {import(\"../Tile.js\").default} [TileType=import(\"../Tile.js\").default]\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     * @protected\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || getUid(this);\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    const tileGrid = projection\n      ? this.getTileGridForProjection(projection)\n      : this.tileGrid;\n    if (!tileGrid) {\n      return null;\n    }\n    return tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    }\n    return this.tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    }\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    const gridProjection =\n      projection !== undefined ? projection : this.getProjection();\n    const tileGrid =\n      projection !== undefined\n        ? this.getTileGridForProjection(gridProjection)\n        : this.tileGrid || this.getTileGridForProjection(gridProjection);\n    if (this.getWrapX() && gridProjection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, gridProjection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.\n   * @api\n   */\n  clear() {}\n\n  /**\n   * @override\n   */\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n", "/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {toPromise} from '../functions.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\n */\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {AbortSignal} signal An abort controller signal.\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\n * underlying tile grid does not have a known extent.\n */\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {string} [key] Key for use in caching tiles.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\n * @extends TileSource<TileType>\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @private\n     */\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {CrossOriginAttribute}\n     */\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\n\n    /**\n     * @type {import(\"../transform.js\").Transform|null}\n     */\n    this.transformMatrix = null;\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!TileType} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const sourceTileGrid =\n      this.tileGrid || this.getTileGridForProjection(sourceProj || targetProj);\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      sourceTileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(sourceTileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1],\n        );\n      }),\n    );\n\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj,\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj: sourceProj || targetProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.gutter_,\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio),\n        transformMatrix: this.transformMatrix,\n      },\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\n    );\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new ReprojDataTile(options))\n    );\n    tile.key = this.getKey();\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {TileType|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      projection &&\n      ((sourceProjection && !equivalent(sourceProjection, projection)) ||\n        this.transformMatrix)\n    ) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n\n    const sourceLoader = this.loader_;\n\n    const controller = new AbortController();\n\n    /**\n     * @type {LoaderOptions}\n     */\n    const loaderOptions = {\n      signal: controller.signal,\n      crossOrigin: this.crossOrigin_,\n    };\n\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\n    if (!tileCoord) {\n      return null;\n    }\n\n    const requestZ = tileCoord[0];\n    const requestX = tileCoord[1];\n    const requestY = tileCoord[2];\n    const range = this.getTileGrid()?.getFullTileRange(requestZ);\n    if (range) {\n      loaderOptions.maxY = range.getHeight() - 1;\n    }\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\n      });\n    }\n\n    /**\n     * @type {import(\"../DataTile.js\").Options}\n     */\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n        controller: controller,\n      },\n      this.tileOptions,\n    );\n\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new DataTile(options))\n    );\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (\n      this.tileGrid &&\n      (!thisProj || equivalent(thisProj, projection)) &&\n      !this.transformMatrix\n    ) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n}\n\nexport default DataTileSource;\n", "/**\n * @module ol/uri\n */\n\nimport {hashZXY} from './tilecoord.js';\nimport {modulo} from './math.js';\n\n/**\n * Appends query parameters to a URI.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object} params An object where keys are URI-encoded parameter keys,\n *     and the values are arbitrary types or arrays.\n * @return {string} The new URI.\n */\nexport function appendParams(uri, params) {\n  /** @type {Array<string>} */\n  const keyParams = [];\n  // Skip any null or undefined parameter values\n  Object.keys(params).forEach(function (k) {\n    if (params[k] !== null && params[k] !== undefined) {\n      keyParams.push(k + '=' + encodeURIComponent(params[k]));\n    }\n  });\n  const qs = keyParams.join('&');\n  // remove any trailing ? or &\n  uri = uri.replace(/[?&]$/, '');\n  // append ? or & depending on whether uri has existing parameters\n  uri += uri.includes('?') ? '&' : '?';\n  return uri + qs;\n}\n\nconst zRegEx = /\\{z\\}/g;\nconst xRegEx = /\\{x\\}/g;\nconst yRegEx = /\\{y\\}/g;\nconst dashYRegEx = /\\{-y\\}/g;\n\n/**\n * @param {string} template The URL template.  Should have `{x}`, `{y}`, and `{z}` placeholders.  If\n * the template has a `{-y}` placeholder, the `maxY` parameter must be supplied.\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @param {number} [maxY] The maximum y coordinate at the given z level.\n * @return {string} The URL.\n */\nexport function renderXYZTemplate(template, z, x, y, maxY) {\n  return template\n    .replace(zRegEx, z.toString())\n    .replace(xRegEx, x.toString())\n    .replace(yRegEx, y.toString())\n    .replace(dashYRegEx, function () {\n      if (maxY === undefined) {\n        throw new Error(\n          'If the URL template has a {-y} placeholder, the grid extent must be known',\n        );\n      }\n      return (maxY - y).toString();\n    });\n}\n\n/**\n * @param {Array<string>} urls List of URLs.\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @return {string} The chosen URL.\n */\nexport function pickUrl(urls, z, x, y) {\n  const hash = hashZXY(z, x, y);\n  const index = modulo(hash, urls.length);\n  return urls[index];\n}\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  const urls = [];\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    const startCharCode = match[1].charCodeAt(0);\n    const stopCharCode = match[2].charCodeAt(0);\n    let charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    const stop = parseInt(match[2], 10);\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n", "/**\n * @module ol/source/ImageTile\n */\nimport DataTileSource from './DataTile.js';\nimport {expandUrl, pickUrl, renderXYZTemplate} from '../uri.js';\n\n/**\n * Image tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns an {@link import(\"../DataTile.js\").ImageLike image} or a promise for the same.\n *\n * @typedef {function(number, number, number, import(\"./DataTile.js\").LoaderOptions):(import(\"../DataTile.js\").ImageLike|Promise<import(\"../DataTile.js\").ImageLike>)} Loader\n */\n\n/**\n * @typedef {function(number, number, number, import(\"./DataTile.js\").LoaderOptions):string} UrlGetter\n */\n\n/**\n * @typedef {string | Array<string> | UrlGetter} UrlLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {UrlLike} [url] The image URL template.  In addition to a single URL template, an array of URL templates or a function\n * can be provided.  If a function is provided, it will be called with z, x, y tile coordinates and loader options and should\n * return a URL.\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns an {@link import(\"../DataTile.js\").ImageLike image} for a tile or a promise for the same.\n * The promise should not resolve until the image is loaded.  If the `url` option is provided, a loader will be created.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=true] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.\n * @property {import('./DataTile.js').CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\nconst loadError = new Error('Image failed to load');\n\n/**\n * @param {string} template The image url template.\n * @param {number} z The tile z coordinate.\n * @param {number} x The tile x coordinate.\n * @param {number} y The tile y coordinate.\n * @param {import('./DataTile.js').LoaderOptions} options The loader options.\n * @return {Promise<HTMLImageElement>} Resolves with a loaded image.\n */\nfunction loadImage(template, z, x, y, options) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.crossOrigin = options.crossOrigin ?? null;\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', () => reject(loadError));\n    image.src = renderXYZTemplate(template, z, x, y, options.maxY);\n  });\n}\n\n/**\n * @param {Array<string>} templates The url templates.\n * @return {Loader} The image loader.\n */\nfunction makeLoaderFromTemplates(templates) {\n  return function (z, x, y, options) {\n    const template = pickUrl(templates, z, x, y);\n    return loadImage(template, z, x, y, options);\n  };\n}\n\n/**\n * @param {UrlGetter} getter The url getter.\n * @return {Loader} The image loader.\n */\nfunction makeLoaderFromGetter(getter) {\n  return function (z, x, y, options) {\n    const url = getter(z, x, y, options);\n    return loadImage(url, z, x, y, options);\n  };\n}\n\n/**\n * @param {UrlLike} url The URL-like option.\n * @return {Loader} The tile loader.\n */\nfunction makeLoaderFromUrlLike(url) {\n  /**\n   * @type {Loader}\n   */\n  let loader;\n\n  if (Array.isArray(url)) {\n    loader = makeLoaderFromTemplates(url);\n  } else if (typeof url === 'string') {\n    const urls = expandUrl(url);\n    loader = makeLoaderFromTemplates(urls);\n  } else if (typeof url === 'function') {\n    loader = makeLoaderFromGetter(url);\n  } else {\n    throw new Error(\n      'The url option must be a single template, an array of templates, or a function for getting a URL',\n    );\n  }\n  return loader;\n}\n\nlet keyCount = 0;\n\n/**\n * @param {UrlLike} url The URL-like option.\n * @return {string} A key for the URL.\n */\nfunction keyFromUrlLike(url) {\n  if (Array.isArray(url)) {\n    return url.join('\\n');\n  }\n\n  if (typeof url === 'string') {\n    return url;\n  }\n\n  ++keyCount;\n  return 'url-function-key-' + keyCount;\n}\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @extends DataTileSource<import(\"../ImageTile.js\").default>\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass ImageTileSource extends DataTileSource {\n  /**\n   * @param {Options} [options] DataTile source options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @type {Loader}\n     */\n    let loader = options.loader;\n\n    /**\n     * @type {string}\n     */\n    let key;\n\n    if (options.url) {\n      loader = makeLoaderFromUrlLike(options.url);\n      key = keyFromUrlLike(options.url);\n    }\n\n    /**\n     * @type {import('./Source.js').State}\n     */\n    const state = !loader ? 'loading' : options.state;\n\n    const wrapX = options.wrapX === undefined ? true : options.wrapX;\n\n    super({\n      loader: loader,\n      key: key,\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize,\n      gutter: options.gutter,\n      maxResolution: options.maxResolution,\n      projection: options.projection,\n      tileGrid: options.tileGrid,\n      state: state,\n      wrapX: wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      crossOrigin: options.crossOrigin,\n      zDirection: options.zDirection,\n    });\n  }\n\n  /**\n   * @param {UrlLike} url The new URL.\n   * @api\n   */\n  setUrl(url) {\n    const loader = makeLoaderFromUrlLike(url);\n    this.setLoader(loader);\n    this.setKey(keyFromUrlLike(url));\n    if (this.getState() !== 'ready') {\n      this.setState('ready');\n    }\n  }\n}\n\nexport default ImageTileSource;\n"],
  "mappings": "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",
  "names": ["createOrUpdate", "scale", "z", "x", "y", "DataTile_default", "DataTile_default", "wrapX"]
}
