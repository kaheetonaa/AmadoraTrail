import {
  OBJECT_PROPERTY_NODE_FACTORY,
  XMLFeature_default,
  XML_SCHEMA_INSTANCE_URI,
  createElementNS,
  getAllTextContent,
  getDocument,
  isDocument,
  makeArrayPusher,
  makeArraySerializer,
  makeChildAppender,
  makeObjectPropertySetter,
  makeSequence,
  makeSimpleNodeFactory,
  makeStructureNS,
  parse,
  parseNode,
  pushParseAndPop,
  pushSerializeAndPop
} from "./chunk-FE2YRNVE.js";
import {
  transformGeometryWithOptions
} from "./chunk-GJ2WXTGG.js";
import "./chunk-I7EEP5ZN.js";
import {
  Feature_default
} from "./chunk-CH6UO2UB.js";
import {
  MultiLineString_default
} from "./chunk-DF37ZPJ5.js";
import {
  LineString_default
} from "./chunk-55HYMNF3.js";
import {
  Point_default
} from "./chunk-H5FP6E5U.js";
import "./chunk-JAYUBSBV.js";
import "./chunk-TWLEFCSZ.js";
import "./chunk-VX7HJFTJ.js";
import {
  get,
  padNumber
} from "./chunk-XK3XNXS2.js";
import "./chunk-V7KTD4MH.js";
import "./chunk-UU325GWC.js";

// node_modules/ol/format/xsd.js
function readDateTime(node) {
  const s = getAllTextContent(node, false);
  const dateTime = Date.parse(s);
  return isNaN(dateTime) ? void 0 : dateTime / 1e3;
}
function readDecimal(node) {
  const s = getAllTextContent(node, false);
  return readDecimalString(s);
}
function readDecimalString(string) {
  const m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m) {
    return parseFloat(m[1]);
  }
  return void 0;
}
function readPositiveInteger(node) {
  const s = getAllTextContent(node, false);
  return readNonNegativeIntegerString(s);
}
function readNonNegativeIntegerString(string) {
  const m = /^\s*(\d+)\s*$/.exec(string);
  if (m) {
    return parseInt(m[1], 10);
  }
  return void 0;
}
function readString(node) {
  return getAllTextContent(node, false).trim();
}
function writeDateTimeTextNode(node, dateTime) {
  const date = new Date(dateTime * 1e3);
  const string = date.getUTCFullYear() + "-" + padNumber(date.getUTCMonth() + 1, 2) + "-" + padNumber(date.getUTCDate(), 2) + "T" + padNumber(date.getUTCHours(), 2) + ":" + padNumber(date.getUTCMinutes(), 2) + ":" + padNumber(date.getUTCSeconds(), 2) + "Z";
  node.appendChild(getDocument().createTextNode(string));
}
function writeDecimalTextNode(node, decimal) {
  const string = decimal.toPrecision();
  node.appendChild(getDocument().createTextNode(string));
}
function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
  const string = nonNegativeInteger.toString();
  node.appendChild(getDocument().createTextNode(string));
}
function writeStringTextNode(node, string) {
  node.appendChild(getDocument().createTextNode(string));
}

// node_modules/ol/format/GPX.js
var NAMESPACE_URIS = [
  null,
  "http://www.topografix.com/GPX/1/0",
  "http://www.topografix.com/GPX/1/1"
];
var SCHEMA_LOCATION = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
var FEATURE_READER = {
  "rte": readRte,
  "trk": readTrk,
  "wpt": readWpt
};
var GPX_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "rte": makeArrayPusher(readRte),
  "trk": makeArrayPusher(readTrk),
  "wpt": makeArrayPusher(readWpt)
});
var LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "text": makeObjectPropertySetter(readString, "linkText"),
  "type": makeObjectPropertySetter(readString, "linkType")
});
var AUTHOR_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "email": parseEmail,
  "link": parseLink
});
var METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "author": makeObjectPropertySetter(readAuthor),
  "copyright": makeObjectPropertySetter(readCopyright),
  "link": parseLink,
  "time": makeObjectPropertySetter(readDateTime),
  "keywords": makeObjectPropertySetter(readString),
  "bounds": parseBounds,
  "extensions": parseExtensions
});
var COPYRIGHT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "year": makeObjectPropertySetter(readPositiveInteger),
  "license": makeObjectPropertySetter(readString)
});
var GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "rte": makeChildAppender(writeRte),
  "trk": makeChildAppender(writeTrk),
  "wpt": makeChildAppender(writeWpt)
});
var GPX = class extends XMLFeature_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = get("EPSG:4326");
    this.readExtensions_ = options.readExtensions;
  }
  /**
   * @param {Array<Feature>} features List of features.
   * @private
   */
  handleReadExtensions_(features) {
    if (!features) {
      features = [];
    }
    for (let i = 0, ii = features.length; i < ii; ++i) {
      const feature = features[i];
      if (this.readExtensions_) {
        const extensionsNode = feature.get("extensionsNode_") || null;
        this.readExtensions_(feature, extensionsNode);
      }
      feature.set("extensionsNode_", void 0);
    }
  }
  /**
   * Reads a GPX file's metadata tag, reading among other things:
   *   - the name and description of this GPX
   *   - its author
   *   - the copyright associated with this GPX file
   *
   * Will return null if no metadata tag is present (or no valid source is given).
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {GPXMetadata | null} Metadata
   * @api
   */
  readMetadata(source) {
    if (!source) {
      return null;
    }
    if (typeof source === "string") {
      return this.readMetadataFromDocument(parse(source));
    }
    if (isDocument(source)) {
      return this.readMetadataFromDocument(
        /** @type {Document} */
        source
      );
    }
    return this.readMetadataFromNode(source);
  }
  /**
   * @param {Document} doc Document.
   * @return {GPXMetadata | null} Metadata
   */
  readMetadataFromDocument(doc) {
    for (let n = (
      /** @type {Node} */
      doc.firstChild
    ); n; n = n.nextSibling) {
      if (n.nodeType === Node.ELEMENT_NODE) {
        const metadata = this.readMetadataFromNode(
          /** @type {Element} */
          n
        );
        if (metadata) {
          return metadata;
        }
      }
    }
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Metadata
   */
  readMetadataFromNode(node) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return null;
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName === "metadata") {
        return pushParseAndPop({}, METADATA_PARSERS, n, []);
      }
    }
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return null;
    }
    const featureReader = FEATURE_READER[node.localName];
    if (!featureReader) {
      return null;
    }
    const feature = featureReader(node, [this.getReadOptions(node, options)]);
    if (!feature) {
      return null;
    }
    this.handleReadExtensions_([feature]);
    return feature;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return [];
    }
    if (node.localName == "gpx") {
      const features = pushParseAndPop([], GPX_PARSERS, node, [
        this.getReadOptions(node, options)
      ]);
      if (features) {
        this.handleReadExtensions_(features);
        return features;
      }
      return [];
    }
    return [];
  }
  /**
   * Encode an array of features in the GPX format as an XML node.
   * LineString geometries are output as routes (`<rte>`), and MultiLineString
   * as tracks (`<trk>`).
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   * @override
   */
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const gpx = createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
    const xmlnsUri = "http://www.w3.org/2000/xmlns/";
    gpx.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    gpx.setAttributeNS(
      XML_SCHEMA_INSTANCE_URI,
      "xsi:schemaLocation",
      SCHEMA_LOCATION
    );
    gpx.setAttribute("version", "1.1");
    gpx.setAttribute("creator", "OpenLayers");
    pushSerializeAndPop(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: gpx },
      GPX_SERIALIZERS,
      GPX_NODE_FACTORY,
      features,
      [options]
    );
    return gpx;
  }
};
var RTE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions,
  "type": makeObjectPropertySetter(readString),
  "rtept": parseRtePt
});
var RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var TRK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "type": makeObjectPropertySetter(readString),
  "extensions": parseExtensions,
  "trkseg": parseTrkSeg
});
var TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "trkpt": parseTrkPt
});
var TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var WPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime),
  "magvar": makeObjectPropertySetter(readDecimal),
  "geoidheight": makeObjectPropertySetter(readDecimal),
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "sym": makeObjectPropertySetter(readString),
  "type": makeObjectPropertySetter(readString),
  "fix": makeObjectPropertySetter(readString),
  "sat": makeObjectPropertySetter(readPositiveInteger),
  "hdop": makeObjectPropertySetter(readDecimal),
  "vdop": makeObjectPropertySetter(readDecimal),
  "pdop": makeObjectPropertySetter(readDecimal),
  "ageofdgpsdata": makeObjectPropertySetter(readDecimal),
  "dgpsid": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions
});
var LINK_SEQUENCE = ["text", "type"];
var LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "text": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode)
});
var RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "rtept"
]);
var RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "rtept": makeArraySerializer(makeChildAppender(writeWptType))
});
var RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ["ele", "time"]);
var TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "trkseg"
]);
var TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "trkseg": makeArraySerializer(makeChildAppender(writeTrkSeg))
});
var TRKSEG_NODE_FACTORY = makeSimpleNodeFactory("trkpt");
var TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "trkpt": makeChildAppender(writeWptType)
});
var WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "ele",
  "time",
  "magvar",
  "geoidheight",
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "sym",
  "type",
  "fix",
  "sat",
  "hdop",
  "vdop",
  "pdop",
  "ageofdgpsdata",
  "dgpsid"
]);
var WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeChildAppender(writeDecimalTextNode),
  "time": makeChildAppender(writeDateTimeTextNode),
  "magvar": makeChildAppender(writeDecimalTextNode),
  "geoidheight": makeChildAppender(writeDecimalTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "sym": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "fix": makeChildAppender(writeStringTextNode),
  "sat": makeChildAppender(writeNonNegativeIntegerTextNode),
  "hdop": makeChildAppender(writeDecimalTextNode),
  "vdop": makeChildAppender(writeDecimalTextNode),
  "pdop": makeChildAppender(writeDecimalTextNode),
  "ageofdgpsdata": makeChildAppender(writeDecimalTextNode),
  "dgpsid": makeChildAppender(writeNonNegativeIntegerTextNode)
});
var GEOMETRY_TYPE_TO_NODENAME = {
  "Point": "wpt",
  "LineString": "rte",
  "MultiLineString": "trk"
};
function GPX_NODE_FACTORY(value, objectStack, nodeName) {
  const geometry = (
    /** @type {Feature} */
    value.getGeometry()
  );
  if (geometry) {
    const nodeName2 = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
    if (nodeName2) {
      const parentNode = objectStack[objectStack.length - 1].node;
      return createElementNS(parentNode.namespaceURI, nodeName2);
    }
  }
}
function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
  flatCoordinates.push(
    parseFloat(node.getAttribute("lon")),
    parseFloat(node.getAttribute("lat"))
  );
  if ("ele" in values) {
    flatCoordinates.push(
      /** @type {number} */
      values["ele"]
    );
    delete values["ele"];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }
  if ("time" in values) {
    flatCoordinates.push(
      /** @type {number} */
      values["time"]
    );
    delete values["time"];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }
  return flatCoordinates;
}
function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
  let layout = "XY";
  let stride = 2;
  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = "XYZM";
    stride = 4;
  } else if (layoutOptions.hasZ) {
    layout = "XYZ";
    stride = 3;
  } else if (layoutOptions.hasM) {
    layout = "XYM";
    stride = 3;
  }
  if (stride !== 4) {
    for (let i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
      flatCoordinates[i * stride] = flatCoordinates[i * 4];
      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
      if (layoutOptions.hasZ) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
      }
      if (layoutOptions.hasM) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
      }
    }
    flatCoordinates.length = flatCoordinates.length / 4 * stride;
    if (ends) {
      for (let i = 0, ii = ends.length; i < ii; i++) {
        ends[i] = ends[i] / 4 * stride;
      }
    }
  }
  return layout;
}
function readAuthor(node, objectStack) {
  const values = pushParseAndPop({}, AUTHOR_PARSERS, node, objectStack);
  if (values) {
    return values;
  }
  return void 0;
}
function readCopyright(node, objectStack) {
  const values = pushParseAndPop({}, COPYRIGHT_PARSERS, node, objectStack);
  if (values) {
    const author = node.getAttribute("author");
    if (author !== null) {
      values["author"] = author;
    }
    return values;
  }
  return void 0;
}
function parseBounds(node, objectStack) {
  const values = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  const minlat = node.getAttribute("minlat");
  const minlon = node.getAttribute("minlon");
  const maxlat = node.getAttribute("maxlat");
  const maxlon = node.getAttribute("maxlon");
  if (minlon !== null && minlat !== null && maxlon !== null && maxlat !== null) {
    values["bounds"] = [
      [parseFloat(minlon), parseFloat(minlat)],
      [parseFloat(maxlon), parseFloat(maxlat)]
    ];
  }
}
function parseEmail(node, objectStack) {
  const values = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  const id = node.getAttribute("id");
  const domain = node.getAttribute("domain");
  if (id !== null && domain !== null) {
    values["email"] = `${id}@${domain}`;
  }
}
function parseLink(node, objectStack) {
  const values = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  const href = node.getAttribute("href");
  if (href !== null) {
    values["link"] = href;
  }
  parseNode(LINK_PARSERS, node, objectStack);
}
function parseExtensions(node, objectStack) {
  const values = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  values["extensionsNode_"] = node;
}
function parseRtePt(node, objectStack) {
  const values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);
  if (values) {
    const rteValues = (
      /** @type {!Object} */
      objectStack[objectStack.length - 1]
    );
    const flatCoordinates = (
      /** @type {Array<number>} */
      rteValues["flatCoordinates"]
    );
    const layoutOptions = (
      /** @type {LayoutOptions} */
      rteValues["layoutOptions"]
    );
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
function parseTrkPt(node, objectStack) {
  const values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);
  if (values) {
    const trkValues = (
      /** @type {!Object} */
      objectStack[objectStack.length - 1]
    );
    const flatCoordinates = (
      /** @type {Array<number>} */
      trkValues["flatCoordinates"]
    );
    const layoutOptions = (
      /** @type {LayoutOptions} */
      trkValues["layoutOptions"]
    );
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
function parseTrkSeg(node, objectStack) {
  const values = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  parseNode(TRKSEG_PARSERS, node, objectStack);
  const flatCoordinates = (
    /** @type {Array<number>} */
    values["flatCoordinates"]
  );
  const ends = (
    /** @type {Array<number>} */
    values["ends"]
  );
  ends.push(flatCoordinates.length);
}
function readRte(node, objectStack) {
  const options = (
    /** @type {import("./Feature.js").ReadOptions} */
    objectStack[0]
  );
  const values = pushParseAndPop(
    {
      "flatCoordinates": [],
      "layoutOptions": {}
    },
    RTE_PARSERS,
    node,
    objectStack
  );
  if (!values) {
    return void 0;
  }
  const flatCoordinates = (
    /** @type {Array<number>} */
    values["flatCoordinates"]
  );
  delete values["flatCoordinates"];
  const layoutOptions = (
    /** @type {LayoutOptions} */
    values["layoutOptions"]
  );
  delete values["layoutOptions"];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates);
  const geometry = new LineString_default(flatCoordinates, layout);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function readTrk(node, objectStack) {
  const options = (
    /** @type {import("./Feature.js").ReadOptions} */
    objectStack[0]
  );
  const values = pushParseAndPop(
    {
      "flatCoordinates": [],
      "ends": [],
      "layoutOptions": {}
    },
    TRK_PARSERS,
    node,
    objectStack
  );
  if (!values) {
    return void 0;
  }
  const flatCoordinates = (
    /** @type {Array<number>} */
    values["flatCoordinates"]
  );
  delete values["flatCoordinates"];
  const ends = (
    /** @type {Array<number>} */
    values["ends"]
  );
  delete values["ends"];
  const layoutOptions = (
    /** @type {LayoutOptions} */
    values["layoutOptions"]
  );
  delete values["layoutOptions"];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
  const geometry = new MultiLineString_default(flatCoordinates, layout, ends);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function readWpt(node, objectStack) {
  const options = (
    /** @type {import("./Feature.js").ReadOptions} */
    objectStack[0]
  );
  const values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);
  if (!values) {
    return void 0;
  }
  const layoutOptions = (
    /** @type {LayoutOptions} */
    {}
  );
  const coordinates = appendCoordinate([], layoutOptions, node, values);
  const layout = applyLayoutOptions(layoutOptions, coordinates);
  const geometry = new Point_default(coordinates, layout);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function writeLink(node, value, objectStack) {
  node.setAttribute("href", value);
  const context = objectStack[objectStack.length - 1];
  const properties = context["properties"];
  const link = [properties["linkText"], properties["linkType"]];
  pushSerializeAndPop(
    /** @type {import("../xml.js").NodeStackItem} */
    { node },
    LINK_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    link,
    objectStack,
    LINK_SEQUENCE
  );
}
function writeWptType(node, coordinate, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const parentNode = context.node;
  const namespaceURI = parentNode.namespaceURI;
  const properties = context["properties"];
  node.setAttributeNS(null, "lat", String(coordinate[1]));
  node.setAttributeNS(null, "lon", String(coordinate[0]));
  const geometryLayout = context["geometryLayout"];
  switch (geometryLayout) {
    case "XYZM":
      if (coordinate[3] !== 0) {
        properties["time"] = coordinate[3];
      }
    // fall through
    case "XYZ":
      if (coordinate[2] !== 0) {
        properties["ele"] = coordinate[2];
      }
      break;
    case "XYM":
      if (coordinate[2] !== 0) {
        properties["time"] = coordinate[2];
      }
      break;
    default:
  }
  const orderedKeys = node.nodeName == "rtept" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    /** @type {import("../xml.js").NodeStackItem} */
    { node, "properties": properties },
    WPT_TYPE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeRte(node, feature, objectStack) {
  const options = (
    /** @type {import("./Feature.js").WriteOptions} */
    objectStack[0]
  );
  const properties = feature.getProperties();
  const context = { node };
  context["properties"] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == "LineString") {
    const lineString = (
      /** @type {LineString} */
      transformGeometryWithOptions(geometry, true, options)
    );
    context["geometryLayout"] = lineString.getLayout();
    properties["rtept"] = lineString.getCoordinates();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    RTE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeTrk(node, feature, objectStack) {
  const options = (
    /** @type {import("./Feature.js").WriteOptions} */
    objectStack[0]
  );
  const properties = feature.getProperties();
  const context = { node };
  context["properties"] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == "MultiLineString") {
    const multiLineString = (
      /** @type {MultiLineString} */
      transformGeometryWithOptions(geometry, true, options)
    );
    properties["trkseg"] = multiLineString.getLineStrings();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    TRK_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeTrkSeg(node, lineString, objectStack) {
  const context = { node };
  context["geometryLayout"] = lineString.getLayout();
  context["properties"] = {};
  pushSerializeAndPop(
    context,
    TRKSEG_SERIALIZERS,
    TRKSEG_NODE_FACTORY,
    lineString.getCoordinates(),
    objectStack
  );
}
function writeWpt(node, feature, objectStack) {
  const options = (
    /** @type {import("./Feature.js").WriteOptions} */
    objectStack[0]
  );
  const context = objectStack[objectStack.length - 1];
  context["properties"] = feature.getProperties();
  const geometry = feature.getGeometry();
  if (geometry.getType() == "Point") {
    const point = (
      /** @type {Point} */
      transformGeometryWithOptions(geometry, true, options)
    );
    context["geometryLayout"] = point.getLayout();
    writeWptType(node, point.getCoordinates(), objectStack);
  }
}
var GPX_default = GPX;
export {
  GPX_default as default
};
//# sourceMappingURL=ol_format_GPX__js.js.map
