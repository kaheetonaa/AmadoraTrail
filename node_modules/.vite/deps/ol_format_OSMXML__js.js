import {
  XMLFeature_default,
  makeStructureNS,
  pushParseAndPop
} from "./chunk-FE2YRNVE.js";
import {
  transformGeometryWithOptions
} from "./chunk-GJ2WXTGG.js";
import "./chunk-I7EEP5ZN.js";
import {
  Feature_default
} from "./chunk-CH6UO2UB.js";
import "./chunk-DF37ZPJ5.js";
import {
  LineString_default
} from "./chunk-55HYMNF3.js";
import {
  Point_default,
  Polygon_default
} from "./chunk-H5FP6E5U.js";
import "./chunk-JAYUBSBV.js";
import "./chunk-TWLEFCSZ.js";
import {
  extend
} from "./chunk-VX7HJFTJ.js";
import {
  get
} from "./chunk-XK3XNXS2.js";
import "./chunk-V7KTD4MH.js";
import {
  isEmpty
} from "./chunk-UU325GWC.js";

// node_modules/ol/format/OSMXML.js
var NAMESPACE_URIS = [null];
var WAY_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "nd": readNd,
  "tag": readTag
});
var PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "node": readNode,
  "way": readWay
});
var OSMXML = class extends XMLFeature_default {
  constructor() {
    super();
    this.dataProjection = get("EPSG:4326");
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(node, options) {
    options = this.getReadOptions(node, options);
    if (node.localName == "osm") {
      const state = pushParseAndPop(
        {
          nodes: {},
          ways: [],
          features: []
        },
        PARSERS,
        node,
        [options]
      );
      for (let j = 0; j < state.ways.length; j++) {
        const values = (
          /** @type {Object} */
          state.ways[j]
        );
        const flatCoordinates = values.flatCoordinates;
        if (!flatCoordinates.length) {
          for (let i = 0, ii = values.ndrefs.length; i < ii; i++) {
            const point = state.nodes[values.ndrefs[i]];
            extend(flatCoordinates, point);
          }
        }
        let geometry;
        if (values.ndrefs[0] == values.ndrefs[values.ndrefs.length - 1]) {
          geometry = new Polygon_default(flatCoordinates, "XY", [
            flatCoordinates.length
          ]);
        } else {
          geometry = new LineString_default(flatCoordinates, "XY");
        }
        transformGeometryWithOptions(geometry, false, options);
        const feature = new Feature_default(geometry);
        if (values.id !== void 0) {
          feature.setId(values.id);
        }
        feature.setProperties(values.tags, true);
        state.features.push(feature);
      }
      if (state.features) {
        return state.features;
      }
    }
    return [];
  }
};
var NODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "tag": readTag
});
function readNode(node, objectStack) {
  const options = (
    /** @type {import("./Feature.js").ReadOptions} */
    objectStack[0]
  );
  const state = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  const id = node.getAttribute("id");
  const coordinates = [
    parseFloat(node.getAttribute("lon")),
    parseFloat(node.getAttribute("lat"))
  ];
  state.nodes[id] = coordinates;
  const values = pushParseAndPop(
    {
      tags: {}
    },
    NODE_PARSERS,
    node,
    objectStack
  );
  if (!isEmpty(values.tags)) {
    const geometry = new Point_default(coordinates);
    transformGeometryWithOptions(geometry, false, options);
    const feature = new Feature_default(geometry);
    if (id !== void 0) {
      feature.setId(id);
    }
    feature.setProperties(values.tags, true);
    state.features.push(feature);
  }
}
function readWay(node, objectStack) {
  const id = node.getAttribute("id");
  const values = pushParseAndPop(
    {
      id,
      ndrefs: [],
      flatCoordinates: [],
      tags: {}
    },
    WAY_PARSERS,
    node,
    objectStack
  );
  const state = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  state.ways.push(values);
}
function readNd(node, objectStack) {
  const values = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  values.ndrefs.push(node.getAttribute("ref"));
  if (node.hasAttribute("lon") && node.hasAttribute("lat")) {
    values.flatCoordinates.push(parseFloat(node.getAttribute("lon")));
    values.flatCoordinates.push(parseFloat(node.getAttribute("lat")));
  }
}
function readTag(node, objectStack) {
  const values = (
    /** @type {Object} */
    objectStack[objectStack.length - 1]
  );
  values.tags[node.getAttribute("k")] = node.getAttribute("v");
}
var OSMXML_default = OSMXML;
export {
  OSMXML_default as default
};
//# sourceMappingURL=ol_format_OSMXML__js.js.map
